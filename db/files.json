[
    {
        "name": "Lesson 1 - TypeScript",
        "content": "# TypeScript: Complex Data Types, JSON, Map, Filter, Reduce\n\n## PPL 2023 - [Course Website](https://bguppl.github.io/interpreters/)\n## Practical Session - Week #1\n\n### How to Install Node.js and NPM on Windows\n\nNode.js is a JavaScript interpreter. NPM (Node Package Manager) let's you install software (libraries, plugins, frameworks and applications) used to build Node applications. Both are installed using the installer package avaiable from the Node.js web site. The isntallation is pretty straightforward: \n\n1. Download the LTS (version 18) Windows installer from [nodejs.org](https://nodejs.org/en/)\n2. Run the installer (the .msi file you downloaded in the previous step.)\n3. Follow the prompts in the installer (Accept the license agreement, click the NEXT button a bunch of times and accept the default installation settings).\n4. Restart your computer.\n\n#### Test the installation: \n* Open the Windows Command Prompt (press the Win + R keys. Then, type `cmd` and press Enter).\n* To verify node is installed, type `node -v`, then press Enter. You should see a version number (should start with 'v16.').\n* To verify NPM installation, type `npm -v` and press Enter. You should see a version number (should start with '8.').\n\n#### More information:\nFor instructions on how to install other software that will be used throughout the course, please refer to the [useful links](https://bguppl.github.io/interpreters/useful_links.html) section in the course web site.  In particular, see instructions on how to install the TypeScript compiler `tsc` and the Visual Studio Code IDE.\n\n## 1. Types of Values\n\nA **data-type** is a classification of data which indicates what the programmer intends to do with the data. Types correspond to a set of values (eg. the boolean type corresponds to {true,false}, number type corresponds to the infinite set of numeric values), and they define the operations that can be done on the data (e.g. booleans can be computed using logical operators).\n\nWe pay attention to two distinguishable defintions: The **type of a value** (atomic/compound) and the **type of a variable**. The type of a variable may be declared by the programmer of inferred by the type of the value it stores. The type of a value is determined by a defined group to which it belongs. The type of a variable may be different than the type of the value it stores, but they must be compatiable.\n\nApart from atomic types (number, string, boolean), there are **compound types**. Javascript introduces two basic compound types: Arrays and Maps. In Javascript, compound types are called *object* types (note: not to be confused with the more standard term - *object* here simply refers to any value which is not an atomic type)\n\n##### Arrays\n\nArrays are the first basic compound type in Javascript. Here is an example of using arrays:\n\n\n```typescript\n// This is how we declare an array containing the elements 16,8,27,13\nlet a = [16, 8, 27, 13];\n\n// Here's how we use the Array compound value getter:\nconsole.log(a[3]); // ==> 13\n\n// There is also a slice method:\nconsole.log(a.slice(1, 4)); // ==> [ 8, 27, 13 ]\n```\n\n\nLet's check that it is a compound type:\n\n\n```typescript\nconsole.log(typeof a); // ==> 'object'\n```\n\nAnd now the more specific reflection operator: \n\n\n```typescript\nconsole.log(a instanceof Array); // ==> true\n```\n\nThe array we defined above is **homogeneous**, meaning that it contains a single data type. \nThe **homogeneous** array `a` above contains values whose types are `number`. \nArrays in Javascript can be heterogeneous as well: \n\n\n```typescript\nlet manyArray = [1, 'a', '2', \"The Dawn\", true];\n\nconsole.log(`manyArray = ${manyArray}`); // ==> manyArray = 1,a,2,The Dawn,true\n```\n\n##### Maps and `Object.keys`\n\nMaps are the second basic compound type in Javascript:\n\n```typescript\n// This is how we declare them\nlet map = { a: 1, b: 2 };\n\n// This is how we use the Map compound value getter for the values:\nconsole.log(map['a']); // ==> 1\nconsole.log(map.a); // ==> 1\nconsole.log(map['b']); // ==> 2\nconsole.log(map.b); // ==> 2\n\n// And for keys (relevant for both Arrays [the keys there are the indexes] and Maps)\nconsole.log(Object.keys(a)); // ==> [ '0', '1', '2', '3', '4' ]\nconsole.log(Object.keys(map)); // ==> [ 'a', 'b' ]\n```\n\n##### Variable Types\n\nJavascript is a *dynamic language*, meaning that variables are not typed. But when a variable is bound to a value, we can inspect its type at runtime. \n\nTypescript extends Javascript to introduce optional variable types - it is compiled into Javascript and at compilation time, type checking is performed. Let's recall the example from the lectures: \n\n\n```typescript\nlet typedVarNum: number = 6;\nlet typedVarStr: string = \"blue\";\nlet typedVarBool: boolean = true;\n```\n\n## 2. JSON\n\n### 2.1 JSON Review\n\nJSON stands for JavaScript Object Notation and is a standard way to serialize Javascript compound values into strings (and vice-versa). It is widely used to allow data exchange in server-client communication. It serves a role that is similar to XML.\n\nJSON is a **notation** - that is, a way of writing Javascript values in a way that allows reading them back easily. \nMost Javascript values can be written in JSON - but not all of them.\n\nOnce you have a Javascript object, and once there is an agreed-upon-way of \"stringifying\" the object (in our case, the standard way is `JSON.stringify()`), then you can easily pass this string through the network, from a computer to a computer, as passing strings through the network is easy, and the receiving side can only do an agreed-upon way to parse the string into an object (in our case, the standard way is `JSON.parse()`).\n\nThe JSON interface defines the following two methods: \n1. `JSON.stringify(o)` - maps a value to a string\n2. `JSON.parse(s)` - maps a string written according to the JSON syntax to a value\n\nJSON serves a similar goal to that of `Serializable` of Java that we saw in SPL.\n\n\n```typescript\nlet person1 = { name : \"Yosi\", age : 31, city : \"Beer Sheva\" };\nlet person1JSONString = JSON.stringify(person1);\n\nconsole.log(`person1 serialized in JSON = ${person1JSONString}`); // ==> person1 serialized in JSON = {\"name\":\"Yosi\",\"age\":31,\"city\":\"Beer Sheva\"}\nconsole.log(`person1JSONString is of type ${typeof person1JSONString}`); // ==> person1JSONString is of type string\n```\n\n```typescript\nlet person2 = JSON.parse(person1JSONString);\n\nconsole.log(person2); // ==> { name: 'Yosi', age: 31, city: 'Beer Sheva' }\nconsole.log(`person2 is of type ${typeof person2}`); // ==> person2 is of type object\n```\n\nNote that the way values are written in JSON is not exactly the same as we write them in a Javascript program - there are quotes (\"\") around keys for example.\n\nNote also that `stringify()` and `parse()` work on atomic values as well:\n\n\n```typescript\n// note that the input to JSON.parse is a JSON string\nconsole.log(typeof JSON.parse('2')); // ==> number\nconsole.log(typeof JSON.parse('true')); // ==> boolean\nconsole.log(typeof JSON.parse('\"abc\"')); // ==> string\n```\n\nThe values that can be encoded into JSON (let us call them \"JSON values\") must be one of the following types:\n1. `string`\n2. `number`\n3. `boolean`\n4. `null`\n5. a map where all the keys are strings and all the values are JSON values (recursively) \n6. an array where all the values are JSON values\n\nThe Javascript compound data types, *arrays* and *maps*, can be combined in a recursive manner. \nThis applies to JSON as well.\n\nThe Javascript values that **cannot be encoded** into JSON strings are `undefined` and functions.\n\nLet us look at an example of a complex value and how we can describe it in JSON and then how using types can help us describe its structure in a well-documented manner:\n\n\n```typescript\nlet studentsData = {\n    department: \"Computer Science\", \n    students: [\n        { name: \"Alice\", degree: \"PhD\" }\n        { name: \"Bob\", degree: \"MSc\" },\n    ]\n};\n\nlet studentsJSON = JSON.stringify(studentsData);\nconsole.log(studentsJSON); // ==> {\"department\":\"Computer Science\",\"students\":[{\"name\":\"Alice\",\"degree\":\"PhD\"},{\"name\":\"Bob\",\"degree\":\"MSc\"}]}\nconsole.log(`studentsJSON is of type ${typeof studentsJSON}`); // ==> studentsJSON is of type string\nlet studentsJSONParsed = JSON.parse(studentsJSON);\nconsole.log(studentsJSONParsed);\n// ==> \n// {\n//   department: 'Computer Science',\n//   students: [ { name: 'Alice', degree: 'PhD' }, { name: 'Bob', degree: 'MSc' } ]\n// }\nconsole.log(`studentsJSONParsed is of type ${typeof studentsJSONParsed}`); // ==> studentsJSONParsed is of type object\n```\n\nWe verified that this complex structure can be written into JSON, and then parsed back into an identical value (this is a **round-trip** that preserves the value).\n\nWe can look at the type of `studentData` as a **tree** of simpler values:\n* `studentsData` is a map which has 2 keys:\n  * `department` with a value which is a string\n  * `students` with a value which is an embedded array whose items are compound values.\n* The nested values are maps that have 2 keys:\n  * `name` whose value is a `string` \n  *  `degree` whose value is also a `string`\n  \n\n### 2.2 Documenting Complex Values with Type Annotations\n\nWe can describe this structure using the following TypeScript declaration:\n\n```typescript\n{\n    department: string;\n    students: { name: string, degree: string }[]\n}\n```\n\nThis can be made more readable if we name the types, using the **type alias** TypeScript construct to name map compound types:\n\n\n```typescript\ntype Student = {\n    name: string;\n    degree: string;\n}\n\ntype StudentsData = {\n    department: string;\n    students: Student[];\n}\n```\n\nThis type definition is useful to document the type of the expected values that we expect to read.\n\n### 2.3 Working on complex JSON values\n\nIn this section, we will use the methods **map**, **filter**, **reduce** to operate over complex JSON values. \n\nWe will take a videos-database example ([http://reactivex.io/learnrx/](http://reactivex.io/learnrx/)) as a basis for our examples.\n\nSuppose you are a developer at the popular streaming-movie website Netflix, and that your system's *API* uses JSON to communicate data. The JSON values we describe are actual JSON values returned by the Netflix API.\n\nWhen searching for new movie releases, you send a query to the API, and obtain a JSON reply:\n\n\n```typescript\nlet newReleases = [\n        {\n            \"id\": 70111470,\n            \"title\": \"Die Hard\",\n            \"boxart\": \"http://cdn-0.nflximg.com/images/2891/DieHard.jpg\",\n            \"uri\": \"http://api.netflix.com/catalog/titles/movies/70111470\",\n            \"rating\": 4.0,\n            \"bookmark\": []\n        },\n        {\n            \"id\": 654356453,\n            \"title\": \"Bad Boys\",\n            \"boxart\": \"http://cdn-0.nflximg.com/images/2891/BadBoys.jpg\",\n            \"uri\": \"http://api.netflix.com/catalog/titles/movies/70111470\",\n            \"rating\": 5.0,\n            \"bookmark\": [{ id: 432534, time: 65876586 }]\n        },\n        {\n            \"id\": 65432445,\n            \"title\": \"The Chamber\",\n            \"boxart\": \"http://cdn-0.nflximg.com/images/2891/TheChamber.jpg\",\n            \"uri\": \"http://api.netflix.com/catalog/titles/movies/70111470\",\n            \"rating\": 4.0,\n            \"bookmark\": []\n        },\n        {\n            \"id\": 675465,\n            \"title\": \"Fracture\",\n            \"boxart\": \"http://cdn-0.nflximg.com/images/2891/Fracture.jpg\",\n            \"uri\": \"http://api.netflix.com/catalog/titles/movies/70111470\",\n            \"rating\": 5.0,\n            \"bookmark\": [{ id: 432534, time: 65876586 }]\n        }\n    ];\n```\n\nLet us describe the **type** of this value:\n* We observe it is a homogeneous array of map values.\n* Each map value describes a \"movie\" with fields id, title, boxart, uri, rating and bookmark.\n\nThe corresponding TypeScript annotation is:\n\n```typescript\ntype Video = {\n    id: number;\n    title: string;\n    boxart: string;\n    uri: string;\n    rating: number;\n    bookmark: { id: number, time: number }[];\n}\n\ntype Releases = Video[];\n```\n\nThis type annotation lets us think about the data we obtained from the API as an array `[v1, v2, v3, v4]` where each item $$v_i$$ is a map `{ id, title, boxart, uri, rating, bookmark }`.\n\n\n#### 2.3.1 Map over an Array of Videos\n\nWe would like to transform this data into an array of `{ id, title }` properties. \nThis transformation is called a **projection** as we select only some of the properties in the input.\n\nIn terms of types, this transformation maps from the type `Video[]` into the type `{ id: number, title: string }[]`.\n\nA procedural way to achieve this goal would be:\n\n\n```typescript\nfunction getIDsAndTitles_1(reply) {\n    let res = [];\n    for (let i = 0; i < reply.length; i++) {\n        res.push({ id: reply[i].id, title: reply[i].title });\n    }\n    return res;\n}\n\nlet newReleasesIDAndTitle = getIDsAndTitles_1(newReleases);\nconsole.log(newReleasesIDAndTitle);\n// ==> \n// [ { id: 70111470, title: 'Die Hard' },\n//   { id: 654356453, title: 'Bad Boys' },\n//   { id: 65432445, title: 'The Chamber' },\n//   { id: 675465, title: 'Fracture' } ]\n```\n\nA functional way of achieving the same result uses the **map** method (seen in the reading material for week 1) to abstract away the loop and the mutations we observe in the procedural solution (`i++`, `res.push()`).\n\n```typescript\nlet newReleasesIDAndTitle = newReleases.map(x => ({ id: x.id, title: x.title }));\nconsole.log(newReleasesIDAndTitle);\n// ==> \n// [ { id: 70111470, title: 'Die Hard' },\n//   { id: 654356453, title: 'Bad Boys' },\n//   { id: 65432445, title: 'The Chamber' },\n//   { id: 675465, title: 'Fracture' } ]\n```\n\nNote that in this version:\n* There is no loop (`map` abstracts away the loop control structure)\n* There is no variable assignment (no need to define a loop counter `i` and mutate it and to maintain a `res` accumulator variable).\n\nLet us note what is the type of the transformer function we pass as an argument to `map`:\nit gets as an argument `x` an item from `newReleases` - which is of type `Video` - and it returns a map of type `{ id: number, name: title }`.  \n\n#### 2.3.2 Filter an Array of Videos\n\nThe user is quite picky, and would like to search for new releases that have a rating of 5.0 only. \n\nWe can solve this problem using **filter**.\n\nIn terms of types, the operation we want to define maps an array of `Video[]` to an array of `Video[]`.\nThis fits the definition of `filter` - which does not change the type of items in the array.\n\n```typescript\nlet newReleasesOfRating5 = newReleases.filter(x => x.rating === 5);\nconsole.log(newReleasesOfRating5);\n// ==>\n// [ { id: 654356453,\n//     title: 'Bad Boys',\n//     boxart: 'http://cdn-0.nflximg.com/images/2891/BadBoys.jpg',\n//     uri: 'http://api.netflix.com/catalog/titles/movies/70111470',\n//     rating: 5,\n//     bookmark: [ [Object] ] },\n//   { id: 675465,\n//     title: 'Fracture',\n//     boxart: 'http://cdn-0.nflximg.com/images/2891/Fracture.jpg',\n//     uri: 'http://api.netflix.com/catalog/titles/movies/70111470',\n//     rating: 5,\n//     bookmark: [ [Object] ] } ]\n```\n\n#### 2.3.4 Reminder: Reduce and Neutral Elements as Initializers\nCompare the following 5 invocations of `reduce`:\n\n```typescript\n// Compute the sum of an array of integers\n[1, 2, 3].reduce((acc, cur) => acc + cur, 0); // ==> 6\n\n// Compute the product of an array of integers\n[1, 2, 3].reduce((acc, cur) => acc * cur, 1); // ==> 6\n\n// Compute the logical and of an array of booleans\n[true, false, true].reduce((acc, cur) => acc && cur, true); // ==> false\n\n// Compute the logical or of an array of booleans\n[true, false, true].reduce((acc, cur) => acc || cur, false); // ==> true\n\n// Compute the max of an array of numbers\n[3, 1, 4].reduce((acc,cur) => Math.max(acc,cur), 0); // ==> 4\n```\n\nNote that in all 5 cases, the initializer passed to `reduce(reducer, init)` is the neutral element of the reducer operator (0 for `+`, 1 for `*`, `true` for `and`, `false` for `or`).\n\nThis makes sense in general - and allows one to answer the puzzling question of **what should be the value of reduce when applied to an empty array**.  The general answer is that it should be the neutral element of the reducer.\n\n**NOTE**: the `max` version takes as an initializer the value 0.  This is not correct when the array can contain negative numbers.  What should be the initial value in this case?\n\n#### 2.3.5 Rectangle Selection with Reduce\n\nA user has chosen to view movies as boxarts (that is, the image that is shown for each movie), as it is easier to select movies according to their boxarts. The API returned the following value as a reply to our query:\n\n\n```typescript\nlet boxarts = [\n    { width: 200, height: 200, url: \"http://cdn-0.nflximg.com/images/2891/Fracture200.jpg\" },\n    { width: 150, height: 200, url: \"http://cdn-0.nflximg.com/images/2891/Fracture150.jpg\" },\n    { width: 300, height: 200, url: \"http://cdn-0.nflximg.com/images/2891/Fracture300.jpg\" },\n    { width: 425, height: 150, url: \"http://cdn-0.nflximg.com/images/2891/Fracture425.jpg\" }\n]\n```\n\nLet us define the type of this returned value: it is a homogeneous array of maps. Each map describes a boxart.\n\n```typescript\ntype Boxart = {\n    width: number; \n    height: number;\n    url: string;\n}\n```\n\nWe would like to find the largest box-art image size, so that we could know what is the maximal size of the image placeholder should be.  We measure rectangles by their area ($$width \\times height$$).\n\nA straightforward way to do this is by going over each boxart, and keeping a temporary variable that holds the largest size out of the boxarts we have seen so far.\n\nIn terms of types, the transformation maps an array `Boxart[]` into a `number`. Let us annotate this type into the function definition:\n\n\n```typescript\ntype Boxart = {\n    width: number; \n    height: number;\n    url: string;\n}\n\nfunction maxBox(boxes: Boxart[]): number {\n    let maxBox = 0;\n    for (let i = 0; i < boxes.length; i++) {\n        let curBoxSize = boxes[i].width * boxes[i].height;\n        if (curBoxSize > maxBox) {\n            maxBox = curBoxSize;\n        }\n    }\n    return maxBox;\n}\nmaxBox(boxarts); // ==> 63750\n```\n\nThis is a case of a loop to accumulate a value from an array of values. In terms of types, it maps an array to a single value. The **reduce** method fits perfectly for this scenario: The `reduce` method takes as parameter a reducer function and an initial value, and returns the accumulated value. \n\nThe reducer function takes two arguments: the current accumulator, and the current item. The return value of the reducer function is the \"successive\" value of the accumulator parameter. That is, the result of some operation applied to the current accumulator, and the current item.\n\nOur current accumulator should be the current largest box-art image size, and the initial value should be 0.\n\n```typescript\nlet largestBoxartSize = boxarts.reduce(\n    (curMax,curBox) => {\n        let curBoxSize = curBox.width * curBox.height;\n           if (curBoxSize > curMax) {\n               return curBoxSize;\n           } else {\n               return curMax;\n           }\n    }, // this is the reducer function\n    0  // this is the initial value\n    );\n    \nconsole.log(largestBoxartSize); // ==> 63750\n```\n\nIndeed, the largest boxart image size is 63750, which is the 4th boxart.\n\nNote that this version has no side effect, no mutation and no loop.\n\nWe can make this version more readable by using the Math.max function - to express clearly that what we are doing in this `reduce` invocation is the identification of the max of an array.  We also annotate the expected type of the parameters in the reducer.\n\n```typescript\nconst boxSize = (box: Boxart) => box.width * box.height;\nlet maxBoxSize = boxarts.reduce((curMax: number, curBox: Boxart) => Math.max(curMax, boxSize(curBox)), 0);\n\nconsole.log(maxBoxSize); // ==> 63750\n```\n\n### 2.4 Tree Values\n\nSome replies will be more complex than what we have witnessed above: it is very often that we face replies that have a **tree** form, as opposed to a flat homogeneous array.\n\nOne example of such, is the following API reply - which returns values grouped by movie genre (\"New Releases\", \"Dramas\" ...)\n\n```typescript\nlet movieLists = [\n        {\n            name: \"New Releases\",\n            videos: [\n                {\n                    \"id\": 70111470,\n                    \"title\": \"Die Hard\",\n                    \"boxart\": \"http://cdn-0.nflximg.com/images/2891/DieHard.jpg\",\n                    \"uri\": \"http://api.netflix.com/catalog/titles/movies/70111470\",\n                    \"rating\": 4.0,\n                    \"bookmark\": []\n                },\n                {\n                    \"id\": 654356453,\n                    \"title\": \"Bad Boys\",\n                    \"boxart\": \"http://cdn-0.nflximg.com/images/2891/BadBoys.jpg\",\n                    \"uri\": \"http://api.netflix.com/catalog/titles/movies/70111470\",\n                    \"rating\": 5.0,\n                    \"bookmark\": [{ id: 432534, time: 65876586 }]\n                }\n            ]\n        },\n        {\n            name: \"Dramas\",\n            videos: [\n                {\n                    \"id\": 65432445,\n                    \"title\": \"The Chamber\",\n                    \"boxart\": \"http://cdn-0.nflximg.com/images/2891/TheChamber.jpg\",\n                    \"uri\": \"http://api.netflix.com/catalog/titles/movies/70111470\",\n                    \"rating\": 4.0,\n                    \"bookmark\": []\n                },\n                {\n                    \"id\": 675465,\n                    \"title\": \"Fracture\",\n                    \"boxart\": \"http://cdn-0.nflximg.com/images/2891/Fracture.jpg\",\n                    \"uri\": \"http://api.netflix.com/catalog/titles/movies/70111470\",\n                    \"rating\": 5.0,\n                    \"bookmark\": [{ id: 432534, time: 65876586 }]\n                }\n            ]\n        }\n    ]\n```\n\nTo document the structure of this value, let us write its type:\n* It is an array of 2 maps of identical structure.\n* Each item represents a category of Videos. The category maps have the following keys:\n  * name: string\n  * videos: an array of Video.\n\nThe TypeScript definition is thus:\n\n```typescript\ntype VideoCategory = {\n    name: string;\n    videos: Video[];\n}\ntype VideoCategories = VideoCategory[];\n```\n\nThe structure of the value is thus a *tree*: $$[ category_1, category_2 ]$$ where $$category_i$$ is of the form:<br>\n`{ name: string, videos: [v1,...] }`.\n\nThese kinds of trees impose a challenge when working with them: if we apply `map` or `filter`, the transformer or the predicate will receive as argument a `VideoCategory` object.  If we want to process the embedded `Video` objects inside the categories, we must first **flatten** the tree.\n\nSuppose we would like to have a list of all movie ids in that tree. The most trivial way, as before, is to do the following (using a foreach loop):\n\n```typescript\nlet movieIds = []\nmovieLists.forEach(category => category.videos.forEach(video => movieIds.push(video.id)));\nconsole.log(`movieIds=${movieIds}`); // ==> movieIds=70111470,654356453,65432445,675465\n```\n\n`forEach` abstracts a single loop. The embedded calls to `forEach` inside `forEach` reflects the two-level traversal of the tree.\n\nNote that `forEach` is **not a functional** style: this is precisely the type of operations we want to abstract away using map/filter/reduce. This version has an accumulator variable (`movieIds`) which we must initialize and then mutate as part of the `forEach` iteration.\n\nNot a functional solution...\n\nThe general feeling of the task we want to perform is an **accumulation** - so that `reduce` seems to be the good tool. But we cannot apply `reduce` as is, because `reduce` would work on `Category` values and we want to accumulate `Video` values.\n\nAlternatively, we could attempt to use **map** as we are mapping `Video` values into `number` values.  But again, we cannot map over Categories - we need to map over Videos - so that `map` cannot be used directly.\n\nLet's recall the `concat` method of arrays:\n\n```typescript\nlet arrayOne = [1, 2, 3, 4];\nlet arrayTwo = [5, 6, 7, 8];\narrayOne.concat(arrayTwo); // ==> [ 1, 2, 3, 4, 5, 6, 7, 8 ]\n```\n\nIn contrast to `push`, `concat` does not mutate its arguments - it returns a new array and can be used safely.\n\nIf we `reduce` an array of arrays and accumulate using the `concat` operator,  we will get a method that flattens one level of an array of arrays:\n\n```typescript\nlet a = [[1, 2, 3], [4, 5, 6]];\na.reduce((acc, curr) => acc.concat(curr), []); // ==> [ 1, 2, 3, 4, 5, 6 ]\n```\n\nWe now need to apply a mixture of `map` and `reduce` in order to map and flatten:\n\n```typescript\n// We want the following as an array of the numbers:\nlet a = [{ group: 1, numbers: [1, 2, 3] }, { group: 2, numbers: [4, 5, 6] }];\na.map(x => x.numbers).reduce((acc,curr) => acc.concat(curr), []); // ==> [ 1, 2, 3, 4, 5, 6 ]\n```\n\n### 2.4.1 The Ramda package\n\nRamda is a library of functions designed to facilitate functional programming in JavaScript.\n\nRamda includes a function called `chain` (often also called `flatmap`) which can come handy in our last example: If we want to return all of the results as a single flat array instead of as an array of arrays, then we can use Ramda's `chain`:\n\n```typescript\nimport * as R from \"ramda\";\n\nR.chain(x => x.numbers, a); // ==> [ 1, 2, 3, 4, 5, 6 ]\n```\n\nThe `chain` function goes through an array, and flattens the result of 'doing something' (which can be 'nothing' or applying a 'mapping') by one level.\n\nBack to our videos example, if we `chain` the `movieLists` with a function that just returns the category videos, then the result would be an array containing the videos. As such:\n\n```typescript\nR.chain(category => category.videos, movieLists);\n// ==>\n// [ { id: 70111470,\n//     title: 'Die Hard',\n//     boxart: 'http://cdn-0.nflximg.com/images/2891/DieHard.jpg',\n//     uri: 'http://api.netflix.com/catalog/titles/movies/70111470',\n//     rating: 4,\n//     bookmark: [] },\n//   { id: 654356453,\n//     title: 'Bad Boys',\n//     boxart: 'http://cdn-0.nflximg.com/images/2891/BadBoys.jpg',\n//     uri: 'http://api.netflix.com/catalog/titles/movies/70111470',\n//     rating: 5,\n//     bookmark: [ [Object] ] },\n//   { id: 65432445,\n//     title: 'The Chamber',\n//     boxart: 'http://cdn-0.nflximg.com/images/2891/TheChamber.jpg',\n//     uri: 'http://api.netflix.com/catalog/titles/movies/70111470',\n//     rating: 4,\n//     bookmark: [] },\n//   { id: 675465,\n//     title: 'Fracture',\n//     boxart: 'http://cdn-0.nflximg.com/images/2891/Fracture.jpg',\n//     uri: 'http://api.netflix.com/catalog/titles/movies/70111470',\n//     rating: 5,\n//     bookmark: [ [Object] ] } ]\n```\n\nThe only change that is left, is that we do not want the category videos flattened, rather something extra: taking the `category.videos` and mapping each element there to its `id`.\n\n```typescript\nR.chain(category => category.videos, movieLists).map(video => video.id); // ==> [ 70111470, 654356453, 65432445, 675465 ]\n```\n\nIt helps to annotate the types of the arguments in such chained transformations to document and verify their correctness:\n\n```typescript\nR.chain((category: VideoCategory) => category.videos, movieLists).map((video: Video) => video.id); // ==> [ 70111470, 654356453, 65432445, 675465 ]\n```\n\n## 3. Exercises\n\n### 3.1 Implement the `map` method using `reduce`\n\nLet's think step by step: What should be our *accumulated* value? It is natural to think that the accumulation consists in 'pushing' the current element **as a mapped value** to the currently accumulated array.\n\nTo that end, the initial value should be the empty array. As we go, we will take the current element, and our next accumulator will be the current accumulator, only expanded by the current element after it is mapped by the transformer.\n\n[Solution](./ps1_sol.html#exercise-1-implementing-map-with-reduce)\n\n### 3.2 Implement `filter` using `reduce`\n\nWhat should be changed in the solution of the previous exercise?\n\nWe can skip adding the current element if it does not satisfy the predicate, in which case the next accumulator will not change. However, if the current element does satisfy the predicate, we will set the next accumulator to be the current one, only enlarged by the current element\n\n[Solution](./ps1_sol.html#exercise-2-implementing-filter-with-reduce)\n\n### 3.3 Implement `some` and `every` using `map` and `reduce`\n\n`some(pred)` is a method that returns `true` if and only if *at least one* element in an array satisfies a given predicate.\n\n`every(pred)` is a method that returns true if and only if *all* the elements in an array satisfy a given predicate.\n\nFor example:\n\n```typescript\nlet even = (x => x % 2 == 0);\nlet arr1 = [1,2,3,4];\nlet arr2 = [1,3,5,7];\nlet arr3 = [2,4,6,8];\nlet arr1HasEvenNumbers = arr1.some(even);\nlet arr2HasEvenNumbers = arr2.some(even);\nlet allInArr1AreEven = arr1.every(even);\nlet allInArr3AreEven = arr3.every(even);\nconsole.log(`arr1HasEvenNumbers = ${arr1HasEvenNumbers}`); // ==> arr1HasEvenNumbers = true\nconsole.log(`arr2HasEvenNumbers = ${arr2HasEvenNumbers}`); // ==> arr2HasEvenNumbers = false\nconsole.log(`allInArr1AreEven = ${allInArr1AreEven}`); // ==> allInArr1AreEven = false\nconsole.log(`allInArr3AreEven = ${allInArr3AreEven}`); // ==> allInArr3AreEven = true\n```\n\nInstructions: \n\nA way to implement `some` is by mapping the array to `true/false` values of whether each element satisfies the predicate, and then doing an accumulated logical `or` between the elements using `reduce`, with the initial accumulator equal to `false`.\n\nSimilarly, we can implement `every` in the same way as above, except that we need to use a logical `and` and our initial accumulator should be `true`.\n\n[Solution](./ps1_sol.html#exercise-3-implementing-some-and-every-with-map-and-reduce)\n\n## Shortcut Semantics\n\nThe native `some` and `every` methods employ a concept known as 'shortcut semantics'. What this means, is that `some` stops and immediately returns `true` at the moment it finds an element that satisfies the predicate. `every` stops and immediately returns `false` at the moment it finds an element that does not satisfy the predicate.\n\n**Question**: does our implementation satisfy shortcut semantics?\n\nIt is difficult to distinguish between shortcut semantics and non-shortcut semantics because both shortcut and non-shortcut versions return the same values for all parameters.  \n\nCan we conclude that a shortcut and non-shortcut versions of `some` are equivalent according to the definition of function equivalence we provided in class?\n\nRemember though the difference between mathematical function equivalence and programming functions equivalence: 2 programming functions `f` and `g` are equivalent if they have the same domain, same range and for all values in the domain:\n* Either `f(x)` has a value and `g(x)` has the same value\n* Or `f(x)` does not terminate and `g(x)` does not terminate as well\n* Or `f(x)` throws an error and `g(x)` throws an error as well\n\nHow can we then distinguish between a shortcut semantics version of `some` and one that is not shortcut?\n\nThe solution is to choose parameters that will distinguish between the two computations using either non-termination (infinite loops) or errors.\n\nLet us define such an example on arrays of numbers.  We can trigger an error in JavaScript by using the `throw` primitive.\n\nTo test whether an error was thrown, we use the same syntax as in Java - with `try/catch`.\n\n```typescript\nconst throwOnZero = x => {\n    if (x > 0)\n        return true;\n    else\n        throw false;\n}\n\nlet a = [1, 0];\n\ntry {\n    a.some(throwOnZero);\n} catch (e) {\n    e;\n}\n```\n\nThe code above returns `true`.\n\n```typescript\nconst someExercise = (pred, arr) => arr.map(pred).reduce((acc, cur) => acc || cur, false);\n\ntry {\n    someExercise(throwOnZero, a);\n} catch (e) {\n    e;\n}\n```\n\nThe code above will return `false`.\n\nBy using deliberate error throwing, we are able to distinguish between shortcut and non-shortcut semantics on the definition of the `some` function.\n\nThe next question that arises is whether we can define a version of `some` using `reduce` that has shortcut semantics. We will revisit this question in Chapter 3 of the course, when we introduce generators.\n"
    },
    {
        "name": "Lesson 2 - Type Checking",
        "content": "# TypeScript: Type Checking\n\n## PPL 2023\n## Practical Session - Week #2\n\n### Why Types\n\nAdding types to a program has two key advantages:\n* It allows the compiler to detect errors that would otherwise only be detected at runtime. It is much better to detect errors as early as possible in the development cycle.\n* It serves as excellent documentation by reflecting the intention of the programmer.\n\nTypes also help programmers structure the code they write so that it follows the structure of the data it processes.\n\nIn this session, we review:\n* the syntax of type annotations in TypeScript\n* analyze an example of recursive type definition with the corresponding operations\n* analyze how the type of functions is derived\n\n### Types in TypeScript\n\nTypeScript adds optional type declarations to JavaScript.\nThe principles of this addition are:\n* Type declarations are optional. If they are present, they are checked, otherwise no check is performed. This means that regular JavaScript with no type annotations at all are valid TypeScript expressions.\n* The TypeScript compiler performs two tasks:\n    * It translates a TypeScript program into a JavaScript program\n    * It checks that the program satisfies all the type declarations specified in the program.\n* Type annotations can be implicit and inferred by the TypeScript compiler.\n\n\n```typescript\n// This TypeScript program\nfunction add(a: number, b: number): number {\n    return a + b;\n}\n\nadd(1, 3); // ==> 4\n\n// is translated by `tsc` into this JavaScript program:\nfunction add(a, b) {\n    return a + b;\n}\n\nadd(1, 3); // ==> 4\n```\n\n### Type Annotations\n\nType annotations are optional in TypeScript. They can occur in the following contexts:\n\n```typescript\n// After variable declarations\nlet varName: <typeAnnotation>; \n\n// As part of a function signature\nfunction fname(param : <typeAnnotation>, ...) : <typeAnnotation> { ... } \n\n// With fat arrow notation for functions\n(param: <typeAnnotation>, ...): <typeAnnotation> => ...\n```\n\nType annotations are written in a specific form - which we call the **type language**. \nThe type language is used to describe the expected type of variables, parameters or the values returned by functions.\n\nThe simplest type language expression refers to an **atomic type** - for example `number`, `boolean`, `string`. \nMore complex type language expressions are needed to describe types over compound values.\n\n### Array Type Expressions - Homogeneous Array\n\n\n```typescript\nlet numberArr : number[] = [1, 2, 3];\nlet num: number = numberArr[0];\nconsole.log(num); // ==> 1\n```\n\nOne may use the notation `Array<T>` instead of `T[]`.\n\n### Map Type Expressions\n\nTo describe map types, the following notation is used:\n\n```typescript\n{ <key>: <typeAnnotation>; ... }\n```\n\nFor example:\n\n```typescript\nlet s: { name: string, cs: boolean, age: number } = { name: \"avi\", cs: true, age: 22 };\ns; // => { name: 'avi', cs: true, age: 22 }\n```\n\n### Named Type Expressions\n\nType expressions can be given names. \n\nType expressions can be named using the type alias construct:\n\n```typescript\ntype <typeName> = {\n    <key>: <typeAnnotation>;\n    ...\n}\n```\n\nOr in general, to give a name to any type annotation:\n\n```typescript\ntype <typeName> = <typeAnnotation>;\n```\n\n```typescript\ntype Student = {\n    name: string;\n    cs: boolean;\n    age: number;\n}\n\nlet s: Student = { name: \"avi\", cs: true, age: 22 };\ns; // => { name: 'avi', cs: true, age: 22 }\n```\n\n### Recursive Types\n\nNaming types allows the definition of recursive types. Consider the case of defining a Linked List of numbers:\n\n\n```typescript\ntype NumberLink = {\n    num: number;\n    next?: NumberLink;\n}\n\nlet lst1: NumberLink = {\n    num: 1,\n    next: {\n        num: 2,\n        // The last element does NOT have a next field.\n        next: { num: 3 },\n    }\n};\n\nlst1; // => { num: 1, next: { num: 2, next: { num: 3 } } }\n```\n\n### Operations over Recursive Types\n\nThis type definition is *recursive* - we observe that the definition of the `NumberLink` uses the `NumberLink` type as a component of its own definition.  This type annotation defines a set of values.  Think of this set of values as the set of values which are `map` with a mandatory key `num` with a `number` value and a `next` key which can either not occur, or when it occurs must be of type `NumberLink`.  \n\nThis recursive type, thus, defines a set of *embedded* values - down to a terminal case, where the `next` key is not defined, and the embedding stops.\n\nGiven this type recursive definition, we can define procedures to traverse the linked list from start until a condition is met or until we reach the end of the list.  The following function illustrates the method:\n\n\n```typescript\nconst printNumberLinkedList: (list: NumberLink) => void = list => {\n    // We know list.num is a number\n    console.log(list.num);\n\n    // list.next can either be undefined or a NumberLink\n    if (list.next === undefined) {\n        console.log(\"end of list\");\n    } else {\n        // It is safe to pass a NumberLink value\n        // to the recursive call\n        printNumberLinkedList(list.next);\n    }\n};\n\nprintNumberLinkedList({ num: 1, next: { num: 2, next: { num: 3 } } });\n// ==>\n// 1\n// 2\n// 3\n// end of list\n```\n\nThe structure of the function follows the type definition - when the function receives a value of type `NumberLink`, it knows \nit is a map value, that must contain a `num` key which must be of type `number`.  It is thus safe to invoke `list.num` and to expect a `number` value.  \n\nThen when we need to access the `next` key - the type definition indicates we may find 2 different configurations:\n* Either `next` is not present - in which case, `list.next` will return the `undefined` value.\n* Or `next` is present and it must be a value of type NumberLink.\n\nThe code enumerates these options according to the type definition, and specifies what operations are possible according to the structure of the data that we process.\n\n### Generic Types\n\nConsider the case of defining an **homogeneous generic** Linked List.  This is an abstraction over the previous type definition - we make the type of the values in the linked list a type variable.  This is indicated by the `<T>` component in the type annotation.  \n\n\n```typescript\ntype Link<T> = {\n    x: T;\n    next?: Link<T>;\n}\n\n\nlet lst2: Link<string> = {\n    x: \"avi\",\n    next: { x: \"bob\", next: { x: \"charles\" } }\n};\n\nlst2; // ==> { x: 'avi', next: { x: 'bob', next: { x: 'charles' } } }\n```\n\nThe type variable, T, can be replaced with a compound type as well:\n\n```typescript\nlet lst3: Link<{ name: string }> = {\n    x: { name: \"xx\" },\n    next: { x: { name: \"yy\" }, next: { x: { name: \"last\" } } }\n};\n\nlst3; // ==> { x: { name: 'xx' }, next: { x: { name: 'yy' }, next: { x: [Object] } } }\n```\n\nConsider the case of defining an **heterogeneous** Linked List, we can use the special type called `any` - which denotes the set of all possible values that can be computed by the language:\n\n\n```typescript\nlet lst4: Link<any> = {\n    x: \"hi\",\n    next: { x: 1, next: { x: \"bye\" } }\n};\n\nlst4; // ==> { x: 'hi', next: { x: 1, next: { x: 'bye' } } }\n```\n\nHow can we write a function that operates over a generic data structure such as `Link<T>`?\nDoes the function need to know the type `T` to be useful at all?\n\nThere are three ways when it can be relevant to write an operation over a generic type:\n* Either the operation does not depend on knowledge of the type which is contained;\n* Or the operation itself is a generic function which can be applied to a variety of types.\n* Or we write an operation that is only applicable for a specific instance of the generic type.\n\nLet us see an example of each case: a function which counts how many elements are in a Linked List does not depend on the type of the elements in the list.  We can write it as follows:\n\n\n```typescript\nconst countLink: <T>(list: Link<T>) => number = (list) => {\n    return list.next === undefined ? 1 : 1 + countLink(list.next);\n};\n\ncountLink({ x: \"hi\", next: { x: \"hello\", next: { x: \"bye\" } } }); // => 3\n```\n\nNote how the type of the function must also be marked as a generic function - since it can be applied to parameters for any type `T`.  This is noted with the notation:\n\n```typescript\n<T>(list: Link<T>) => number;\n```\n\nFor the second case, consider the case of the primitive function `console.log()` - it can receive parameters of any type.\nIn this case, we can write a function that operates over the elements in the list even if they are of different types:\n\n\n```typescript\nconst printLink: <T>(list: Link<T>) => void = (list) => {\n    console.log(list.x);\n    list.next === undefined ? console.log(\"end of list\") : printLink(list.next);\n};\n\nprintLink({ x: \"hi\", next: { x: \"hello\", next: { x: \"bye\" } } });\n// ==>\n// hi\n// hello\n// bye\n// end of list\n\nprintLink({ x: 1, next: { x: 2, next: { x: 3 } } });\n// ==>\n// 1\n// 2\n// 3\n// end of list\n```\n\nNote that in the two invocations of the generic functions above, the compiler guesses the type of the parameter (`Link<string>` and `Link<number>`) from inspection of the literal.\n\nThe following invocation on a heterogeneous list, though, will not pass compilation:\n\n```typescript\nprintLink({ x: 1, next: { x: \"a\", next: { x: 3 } } });\n```\n\nThis is because the compiler will not infer on its own that the programmer intends to use an `any` type or a type union.\nTo make this work, the programmer must explicitly indicate that this is what is intended as follows:\n\n\n```typescript\nlet l: Link<any> = { x: 1, next: { x: \"a\", next: { x: 3 } } };\nprintLink(l);\n// ==>\n// 1\n// a\n// 3\n// end of list\n```\n\nThe third option to operate over a generic data type, is to create a function which operates specifically over a type instance of the type variable `T`.  For example, the following function operates only on `List<number>`:\n\n```typescript\nconst squareSumList: (list: Link<number>, acc: number) => number = (list, acc) => {\n    if (list.next === undefined) return acc + list.x * list.x;\n    else return squareSumList(list.next, acc + list.x * list.x);\n};\n\nsquareSumList({ x: 1, next: { x: 2, next: { x: 3 } } }, 0); // = 1*1 + 2*2 + 3*3\n// ==> 14\n```\n\n## Recursive Types: Tree Variations\n\n### Trees with Arbritrary Number of Children\n\nWe saw in class the definition of a `BinTree<T>` type specification. It demonstrated:\n\n* the need for naming types (with the `type` alias construct) to allow recursive type specification\n* the need to define optional properties in maps (with the `key?` notation) to allow the *end of the recursion* in the values.\n\n**Exercise:**\nDefine a Tree with an arbitrary number of children below each node.\n\n\n```typescript\ntype Tree<T> = {\n    root: T;\n    children: Tree<T>[];\n}\n\n// A tree of number nodes with just a root\nlet numbersTree: Tree<number> = {\n    root: 1,\n    children: []\n};\n\n// A tree of string nodes with just a root\nlet stringsTree: Tree<string> = {\n    root: \"tirgul 2\",\n    children: []\n};\n\n// A tree of numbers with one root and 2 children.\nlet t: Tree<number> = {\n    root: 1,\n    children: [\n        { root: 2, children: [] },\n        { root: 3, children: [] }\n    ]\n};\n\n// A heterogeneous tree with string and number nodes\nlet anyTree: Tree<any> = {\n    root: \"numbers and strings\",\n    children: [numbersTree, stringsTree]\n};\n\nanyTree;\n// ==>\n//    { root: 'numbers and strings',\n//      children: \n//       [ { root: 1, children: [] },\n//         { root: 'tirgul 2', children: [] } ] }\n```\n\n**QUESTIONS**: \nIn this case, we did not mark the field `children` as optional in the type definition.\nIt is `children: []` and not `children?: []` as it was in the case of `BinTree` or `Link` above.\n\nWhat is the difference?\n\nWhat are the arguments for and against defining `children` as optional?\n\n**ANSWERS**\n\nThe question is related to the definition of the **base case** vs. **inductive case** in the recursive definition of the type.\n* In the case of `BinTree` and `Link` above, we marked the base case with a key being `undefined`.\n* In the case of `Tree` with many children, we mark the base case with a key of type `Tree[]` being equal to `[]`.\n\nThe decision of what is the base case is completely in the hands of the programmer - so both options are legitimate.\n\nBut we must aim for a situation where the base case is **distinct** from the inductive case - so that they can be easily \ndistinguished when we write code that must decide whether we reached the end of the recursion.  We must make sure as much\nas possible that the type definition we provide allows us to encode:\n* *All the possible values* in the type\n* *Only the possible values* in the type.\n\nIf we defined `Tree` as:\n\n```typescript\ntype Tree<T> = {\n    root: T;\n    children?: Tree<T>[];\n}\n```\nwe could still define all the possible values as requested.\nBut the following two values would also be valid values of the type:\n\n```typescript\n{ root:1, children: [] }\n// and\n{ root: 1 }\n```\n\nThis means we would have two options to represent a leaf in a tree - which would mean it is an ambiguous representation. This would force us to test for the fact that a node is a leaf as follows:\n\n```typescript\nif (root.children.length === 0) || (root.children === undefined) {\n   // ...\n}\n```\nIn this case, we prefer to have a non-ambiguous way to mark the base case - and write only:\n\n```typescript\nif (root.children.length === 0) {\n   // ...\n}\n```\n\nThus, the definition of the type:\n\n```typescript\ntype Tree<T> = {\n    root: T;\n    children: Tree<T>[];\n}\n```\n**without** the `?` option is preferred.\n\n**Exercise:**\nCreate a function that follows a path within the tree and returns the node found at this place.\n\nFirst, how do we encode a path in this tree?\n\nA path must indicate a way to reach a specific node in the tree starting at the root and selecting one of the children at each step.\n\nFor example, let's look at this tree:\n\n\n```typescript\ntype Tree<T> = {\n    root: T;\n    children: Tree<T>[];\n}\n\nconst t: Tree<number> = {\n    root: 0,\n    children: [\n        { root: 2, children: [{ root: 4, children: [] }] },\n        { root: 1, children: [{ root: 3, children: [] }] }\n    ]\n};\n```\n\n![tree](./resources/ps2/tree.png)\n\nWe decide to encode paths as an array of numbers, indicating which child to select among the children of each node on the path:\n\n```\nthe path of the child with {root:4} will be [0,0]\nthe path of the child with {root:3} will be [1,0]\nthe path of the child with {root:2} will be [0]\nthe path of the child with {root:1} will be [1]\n``` \n\nWe know the type of the tree, so we can design a function that will not give errors at runtime.\n\n\n```typescript\nfunction getChild<T>(t: Tree<T>, path: number[]): Tree<T> {\n    if (path.length === 0)\n        // end of path\n        return t;\n    else if (t.children.length === 0)\n        // t is a leaf - cannot go down\n        return t;\n    else return getChild(t.children[path[0]], path.slice(1)); // recursive case\n}\nconsole.log(getChild(t, [0, 0])); // ==> { root: 2, children: [] }\nconsole.log(getChild(t, [1, 0])); // ==> { root: 3, children: [] }\nconsole.log(getChild(t, [1, 0, 0, 0])); // ==> { root: 3, children: [] } (Do not go \"after\" the leaves.)\n```\n\nIn the rest of the semester, we write functions in TypeScript in the style of functional programming, using the fat arrow syntax.\nThe same function will be defined as follows:\n\n```typescript\nconst getChild = <T>(t: Tree<T>, path: number[]): Tree<T> =>\n    // end of the path\n    (path.length === 0) ? t :\n    // t is a leaf - cannot go down\n    (t.children.length === 0) ? t : \n    // recursive case\n    getChild(t.children[path[0]], path.slice(1));\n\nconsole.log(getChild(t, [1, 0]));\n```\n\nThe differences are:\n* The function is defined as a const name and an anonymous function on the right hand side of the const\n* The body of the function is a single expression\n* We use the ternary if expression (as opposed to the if-statement) `test ? then : else`\n* There is no use for the `return` reserved word.\n\n## Function Types\n\n**Review**:\n\nFunctions in Functional Programming languages are values - that is, we can write expressions, which when they are evaluated at run time become functions (more precisely, *closures* - since these values are functions that may capture variable bindings).\n\nWe must have the ability to describe the type of these values and distinguish among different types of functions.\n\nAn untyped function in Javascript has the following form:\n\n```typescript\n// Named function (has global scope)\nfunction add(x, y) {\n    return x + y;\n}\n\n// Anonymous function\nconst myAdd = function (x, y) {\n    return x + y;\n};\n\n// Using the fat arrow notation:\nconst myFatAdd = (x, y) => x + y;\n\nmyFatAdd(3, 5); // ==> 8\n```\n\nWe can first specify the types of the parameters and the return type, in a way similar to the way it would be done in Java. This applies both to named functions and to anonymous functions.\n\n```typescript\n// Named function\nfunction addT(x: number, y: number): number {\n    return x + y;\n}\n\n// Anonymous function\nconst myAdd = function (x: number, y: number): number {\n    return x + y;\n};\n\n// Using the fat arrow notation:\nconst myFatAdd = (x: number, y: number): number => x + y;\n\nmyFatAdd(2, 4); // ==> 6\n```\n\nLet us now write the full type of the function out of the function value:\n\n```typescript\n\nconst myAdd: (x: number, y: number) => number = function (x: number, y: number): number {\n    return x + y;\n};\n\nconst myFatAdd: (x: number, y: number) => number = (x: number, y: number): number => x + y;\n\nmyFatAdd(2, 7); // ==> 9\n```\n\nThe type expression:\n\n```typescript\n(x: number, y: number) => number;\n```\nis a **function type**. The values that this type denotes are functions that map a pair of numbers to a number - in other words, functions whose domain is within  $$Number \\times Number$$ and whose range is within $$Number$$. (Remember that types denote a set of values.)\n\nThis function type together with the name of the parameters is also called the **function signature**.\n\nFunction types include parameter names and parameter types and a return type.\nParameter names are just to help with readability. We could have instead written:\n\n```typescript\nconst myAdd: (baseValue: number, increment: number) => number = function (x: number, y: number): number {\n    return x + y;\n};\n```\n\nAs long as the parameter types align, it\u2019s considered a valid type for the function, regardless of the names you give the parameters in the function type.\n\nThe second part of the function type is the return type. We make it clear which is the return type by using a fat arrow (**=>**) between the parameters and the return type. This is a required part of the function type, so if the function doesn\u2019t return a value (which means this is a function that just has a side-effect - no return value), we use the special type **void** instead of leaving it off.\n\n## Function Types Examples\n\n### 1. Square Function\n\n\n```typescript\nconst square = x => x * x;\nsquare(10); // ==> 100\n```\n\nThe **value** of `square` is a closure.\n\nThe **type** of `square` is: `(x: any) => number`.\n\nWe infer that the return type of the function is `number` because the value of the function is that which is returned when computing its body; the body is an expression of the form `x * x` and the primitive operator `*` returns a `number`.\n\nIn scheme we would also infer that the `x` variable must be of type `number` because it appears as an argument of the `*` operator which works on numbers.\n(We cannot do the same in JavaScript, why?)\n\n### 2. Generic Type Function\n\n```typescript\nconst id = x => x;\nconsole.log(`${id(0)}`); // ==> 0\nconsole.log(`${id(\"tirgul 2\")}`); // ==> tirgul 2\n```\n\nThe function id can be applied on any value - for example: string, boolean, number, but also arrays and maps.\n\nWe mark its argument as a type variable T1 and the type of the function is:\n\n```typescript\n<T1>(x: T1) => T1\n```\n\n**NOTE**: This is the most basic example of a **polymorphic function** - also called a **generic function**.\n\n**NOTE**: Defining this identity function as `<T1>(x: T1) => T1` is very different from defining it as<br> **`(x: any) => any`**. Can you explain why? Give examples of functions to illustrate.\n\n**NOTE**: To mark a function as generic in TypeScript, we must use the syntax:\n`function id<T>(x: T): T { return x; }`.\n\n###  3. Union Type Function\n\nConsider this function:\n\n```typescript\nlet unionFunc = x => {\n    if (x === 0) return 0;\n    else return false;\n};\n\nconsole.log(`${unionFunc(0)}`); // ==> 0\nconsole.log(`${unionFunc(5)}`); // ==> false\n```\n\n**NOTE**: the function can return two different types. \n\nHow can we describe its type? \n\nOne weak description is to use: `(x: number) => any`.\n\nA more informative description would be to use a *type union*:\n`<T1>(x: T1) => number | boolean`.\n\nNote that we could infer that `x` is of type `number` because we compare it to `0`.\nBut the operator `===` is a universal operator in JavaScript and does not require its parameters to be of the same type. In other words, the primitive `===` has type: `(x: any, y: any) => boolean`.\n\n**NOTE**: Do we want to define functions which return union types of this sort?\n\n**Answer**: This is **not** a good idea.  Such functions are surely not defined well if their return value must be described by a *complicated* type of this sort - it is almost always the sign of a bug.\n\nSuch return values are very complicated to consume - if we want to call this function, we must always test the return value as:\n\n```typescript\nlet x = unionFunc(2);\n\nif (typeof x === \"number\")\n    return x + 2;\nelse\n    return 0;\n```\nand we will almost never be able to invoke `g(unionFunc(2))` for usual functions.\n\n### 4. Map Function Type\n\nWe can apply map (of the ramda package) on varied arguments:\n\n```typescript\nimport { map } from \"ramda\";\n\nlet numbersArray = map(x => x + 1, [1, 2, 3]);\nlet stringsArray = map(x => x + \"d\", [\"a\", \"b\", \"c\"]);\nconsole.log(numbersArray); // ==> [ 2, 3, 4 ]\nconsole.log(stringsArray); // ==> [ 'ad', 'bd', 'cd' ]\n```\n\n`map` receives two arguments: a function and an array.\n\nLet us name them `func` and `array`.\n\n`array` can contain items of any type - let us mark it as T1 under the assumption that the array is **homogeneous**.\n\n`func` gets one parameter - which must be of the type of the elements in `array`.\n\nFor each item in `array` it returns a value of a given type - let us call this return type `T2`.\n\nThe type of the parameter `func` is therefore: `(x:T1)=>T2`.\n\nThe value returned by `map` is an array of the values returned by `func` - that is, its type is `T2[]`.\n\nPutting all the elements together: the type of the `map` function is: \n\n```typescript\n<T1, T2>(func: (x: T1) => T2, array: T1[]) => T2[]\n```\n\n### 5. Filter Function Type\n\nWe can apply `filter` (of the ramda package) on varied arguments:\n\n```typescript\nimport { filter } from \"ramda\";\n\nlet numbersArray = filter(x => x % 2 === 0, [1, 2, 3]);\nlet stringsArray = filter(x => x[0] === \"d\", [\"david\", \"dani\", \"moshe\"]);\nconsole.log(numbersArray); // ==> [ 2 ]\nconsole.log(stringsArray); // ==> [ 'david', 'dani' ]\n```\n\nSo what should be the type of the `filter` function?\n\n`filter` receives two parameters: a function `pred` and an `array`.\n\n`array` can contain items of any type - let us call it `T1` under the assumption that the array is **homogeneous**.\n\n`pred` is a function, that gets one parameter of type `T1` and returns a `boolean` value.\n\n`filter` returns a sub-array of the original array, so that the type it returns is `T1[]`.\n\nPutting all elements together, the type of the `filter` function is:\n\n```typescript\n<T1>(pred: (x: T1) => boolean, array: T1[]) => T1[]\n```\n\n### 6. Reduce Function Type\n\nWe can apply `reduce` (of the ramda package) on varied arguments:\n\n```typescript\nimport { reduce } from 'ramda'\n\nlet num = reduce((acc, curr) => acc + curr, 0, [1, 2, 3]);\nlet count = reduce((acc, curr) => acc + curr.length, 0, [\"a\", \"bc\", \"def\"]);\nconsole.log(num); // ==> 6\nconsole.log(count); // ==> 6\n```\n\nSo what should be the type of the `reduce` function?\n\n`reduce` receives 3 arguments: \n* The reducer function `reducer`\n* The initial value `init`\n* The `array`\n\nThe elements of `array` can be of any type - let us call it `T1` under the assumption that the array is **homogeneous**.\n\n`reducer` gets two parameters (`acc` and `curr`) and outputs a value that will be the `acc` at the next iteration.\n`curr` is one of the items of `array` at each iteration.  \nWe infer that:\n* `curr` must be of type `T1` (same type as the elements in `array`)\n* `acc` and `init` must be of the same type `T2`\n* `reducer` is of type: `(acc: T2, curr: T1)=>T2`.\n\n`reduce` eventually returns the last value of `acc` returned by `reducer` - so the type of the return value should be `T2`.\n\nPutting all things together, the type of `reduce` is:\n\n```typescript\n<T1, T2>(reducer: (acc: T2, curr: T1) => T2, init: T2, array: T1[]) => T2\n```\n\n## 7. Compose Function Type\n\nCompose receives two function arguments `f` and `g` and returns a new function as a value:\n\n```typescript\nimport { compose } from 'ramda'\nlet hn = compose(y => y * y, x => x + 1);\nhn(3); // ==> (3 + 1) * (3 + 1) = 16\n```\n\n```typescript\n// Reverse a string: \n// - Make an array of chars out of the string (split(\"\"))\n// - Reverse the array\n// - Join the chars back into a string array.join(\"\")\nconst reverse: (s: string) => string = s => s.split(\"\").reverse().join(\"\");\nreverse(\"abcd\"); // ==> 'dcba'\n```\n\n```typescript\n// Return a new string with all upper case chars\nconst upper: (s: string) => string = s => s.toUpperCase();\nupper(\"abcd\"); // ==> 'ABCD'\n```\n\n```typescript\nlet upperReverse: (s: string) => string = compose(reverse, upper);\nupperReverse(\"abcd\"); // ==> 'DCBA'\n```\n\nWhat is the type of the function `compose`?\n\nThe first parameter `f` receives a value of any type, let us call it `T1` and returns a value of any type `T2`.\n\nThe second parameter `g` receives a value of any type, `T3` and returns a value of any type `T4`.\n\nThe returned value is a function which computes `f(g(x))` for any parameter `x`.\n\nWe infer that the returned function must receive parameters of the same type as `g` - that is `T3`.\n\nIn addition, we infer that the value returned by `g(x)` must be of the type that `f` expects - that is, `T4` must be the same as `T1`.\n\nFinally, the value returned by `f(g(x))` is of the same type as that returned by `f` - that is, `T2`.\n\nPutting all things together - the type of `compose` is:\n\n```typescript\n<T1, T2, T3>(f: (y: T1) => T2, g: (x: T3) => T1) => (x: T3) => T2;\n```\n\nIt helps to renumber the type variables according to the order in which they are computed:\n\n```typescript\n<T1, T2, T3>(f: (y: T2) => T3, g: (x: T1) => T2) => (x: T1) => T3;\n```\n\nwhich can be read as: a value `x` of type `T1` is mapped to a value of type `T2` and then to a value of type `T3`.\n"
    },
    {
        "name": "Lesson 3 - Scheme",
        "content": "# Scheme Intro\n\n## Practical Session - Week 3 PPL@BGU\n\n\nIn this session, we review:\n* Dr. Racket (Scheme)\n* Atomic expressions\n* Compound expressions\n* Primitives in Scheme\n* Design by Contract\n* Types\n* Iterative Functions and Recursive Functions\n\n## Introduction to DrRacket\n\nIn the following practical sessions, we will use the programming language Scheme.\nWe use the Racket interpreter of Scheme.\nProgram files in Racket are saved with extension *.rkt.\n\nYou should install DrRacket software as explained in [Useful Links](https://bguppl.github.io/interpreters/useful_links.html)\n\nThe first time you open DrRacket, you should:\n* Choose a language: Choose Language -> Language -> choose 'Use the language declared in the source'.\n* Close the software and run it again.\n* All the files should start with the line: `#lang racket`\n\n\n## Atomic Expressions\n\nScheme expressions are evaluated by the Interpreter, which computes the expression's value.\n\nAtomic expressions are expressions that do not consist of other sub-expressions.\nThere are several atomic expression types:\n\n* Numbers\n```scheme\n> 3\n3\n> 3.75\n3.75\n```\n\n* Booleans:\n```scheme\n> #t\n#t\n> #f \n#f\n```\n\n* Primitive procedures:\nPrimitives get their values from the programming language (in our case Scheme).\n```scheme\n> +\n#<procedure:+>\n> not\n#<procedure:not>\n> eq?\n#<procedure:eq?>\n```\n\n(`>` is the Interpreter's prompt.)\n\n\n## Compound Expressions (not atomic)\n\nCompound expressions are expressions that contain nested expressions.\nIn Scheme, these expressions are all marked using parentheses `(   )`.\n\nScheme's syntax is based on *prefix notation*, which means the procedures (operator) appear before their arguments (operands) in compound expressions. \nFor example:\n```scheme\n> (- 25 5)\n20\n\n> (number? 3.75)\n#t\n\n> (> (* 4 3) (/ 4 2))\n#t\n```\n\n\n### How Compound Expressions are Evaluated\n\n* evaluate the sub-expressions recursively\n* apply the value of the operator on the values of the operands\n\nWe can represent that evaluation in an *evaluation tree*:\n\n![evaluation_tree](./resources/ps3/PS3_img1.png)\n\n## Abstraction\n\nWe can give names to values of expressions by using a `define` expression. For example:\n```scheme\n> (define pi 3.14159)\n> (define radius 10)\n```\n\nPay attention! `define` is a *special form*: it is a compound expression which is not evaluated like regular compound expressions.\n\nIf we evaluate `define` in standard way, then the variable `radius` would have to be evaluated - which would lead to an error, (because the whole point of define is to give a value to the variable!).\n\n\n### Interpreter Operation - (define var exp)\n\n* evaluate the expression `exp`\n* add the variable `var` and the value to the global environment - it is called a *binding* between the variable and the value.\n\n```scheme\n> pi\n3.14159\n\n> (* pi (* radius radius))\n314.159\n\n> (define perimeter (* 2 pi radius))\n\n> perimeter\n62.8318\n```\n\n**Note**: the evaluation of a define form does not return any value.\n\n**Note**: in our course, we do not allow nested `define` expressions (that is expressions where define appears embedded inside other expressions).\n\n\n## Primitives in Scheme\n\nWe will introduce Scheme primitives as we go.\n\nNote that **in contrast to JavaScript**, primitives in Scheme are strongly typed: they expect a specific type as argument, and they throw an error at runtime\nwhen they are passed a parameter which does not match the expected type.\n\n```scheme\n> (+ 1 #t)\n+: contract violation\n  expected: number?\n  given: #t\n  argument position: 2nd\n  other arguments...:\n   1\n```\n\nAs a starting point, the following primitives are all numeric primitives - that is, their type is [Number * Number -> Number]: `+, *, -, /`\n\nThe following procedures are numeric predicates - that is their type is [Number * Number -> Boolean]: `<>, <, >=, <=, =`\n\n(Note: most primitives in Scheme can take a variable number of parameters as in `(+ 1 2 3)`.)\n\n\n## Procedure Type\n\nWe can define new user procedures (not primitive) by using `lambda` expressions, which is also a special form:\n\n```scheme\n(lambda <formal-parameters> <body>)\n\n> (lambda (rad) (* pi rad rad))\n#<procedure>\n```\n\nlambda is a value constructor of procedures.\n\nThe value of a lambda expression is called `closure`.  Remember to distinguish between syntax (lambda expression) and semantics (closure value).\n\nlambda defines anonymous procedures:\n```scheme\n> ((lambda (rad) (* pi rad rad)) 10)\n314.159\n```\n\nIn this example, rad is a formal parameter of the anonymous procedures.\nThe value 10 is an argument for this procedure. \n\nTo compute the application of a closure to parameters, the interpreter replaces every occurrence of the formal parameter `rad` in the body of the function with the value 10.\n\nWe can combine a `define` expression with `lambda` expressions to define named procedures:\n\n```scheme\n> (define average \n    (lambda (x y) \n      (/ (+ x y) 2)))\n\n> average\n#<procedure:average>\n```\n\nRacket supports another syntax to define procedures (called MIT Style) which is slightly shorter - but means exactly the same thing.\nIt's actually `syntactic sugar` (makes things easier to read or to express). \nNote that we do not allow the use this syntactic sugar in the course. Always write the full form of the lambda expression.\n```scheme\n(define (<procedure-name> <formal-parameters>) <body>)\n\n> (define (average x y) \n    (/ (+ x y) 2))\n\n> (average 4 6)\n5\n\n> (define (area rad) \n    (* pi rad rad))\n\n> (area 1)\n3.14159\n```\n\n### Procedures Summary\n\nThe definition of a procedure consists of:\n* formal parameters\n* body - list of expressions\n\n\n<big>Example 1:</big>\n```scheme\n(define average1 \n  (lambda (x y)\n    (+ x y)\n    (/ (+ x y) 2)))\n```\n\nThe return value of the procedure above is the last expression.\nThe previous expressions are evaluated and the Interpreter ignores them.\n\nSo why do we allow multiple expressions in the body of a procedure? When is it useful?\n\n\n<big>Example 2 - procedure with side effects:</big>\n```scheme\n(define average2 \n  (lambda (x y)\n    (display x)\n    (+ x y)       ;; Useless in this context\n    (newline)\n    (display y)\n    (newline)\n    (/ (+ x y) 2) ;; Return value of the procedure\n  )) \n```\n\nThe variables `display` and `newline` denote Scheme primitives.\n\nThe return value of `display` and `newline` expressions is `void`, but they have a side effect - they print to stdout.\n(`void` is a special value which is used in Scheme to indicate the returned value is of no importance - it is returned by the `(void)` procedure).\n\nThe expression `(+ x y)` is unnecessary, because it does not have a side effect and is in the middle of the sequence of expressions.\n\nThe semantics of the execution of the body is to execute all the expressions in sequence - in the order in which they occur in the body.\n\nOrder is important because of the side-effects.  Sequence is only meaningful when there are side-effects.\n\n\n### Functional Equivalence\n\n**Definition:** Two procedures are functionally equivalent if and only if they either: \nenter into an infinite loop on the same inputs, or throw exceptions on the same inputs, or halt on the same inputs and return the same value on these parameters.\n\n<big>Question 1:</big> Are the procedures `average1` and `average2` functionally equivalent?\n\n<big>Question 2:</big> look at the following procedure:\n\n```scheme\n(define addition (lambda (x y)\n  (+ x y)\n  (display 'ok)))\n\n> (addition 2 4)\nok\n```\n\nWhat should be the value of the expression?\n```scheme\n> (void? (addition 2 4))\nok#t\n```\n\nWhat is the return value?\n```scheme\n(addition 2 (addition 3 5))\n```\n\n## Design By Contract\n\nWhen writing procedures, we follow the *Design by Contract* methodology.\n\nPractically, this means we first specify the contract that the procedure must enforce.\nWe document it as a formatted set of comments before the procedure definition:\n\n```scheme\n; Signature: area-of-ring(outer,inner)\n; Purpose: To compute the area of a ring whose radius is\n;          \u2019outer\u2019 and whose hole has a radius of \u2019inner\u2019\n; Type: [Number*Number -> Number]\n; Example: (area-of-ring 5 3) should produce 50.24\n; Pre-conditions: outer >= 0, inner >= 0, outer >= inner\n; Post-condition: result = PI * outer^2 - PI * inner^2\n; Tests: (area-of-ring 5 3) ==> 50.24\n```\n\n**Signature** specifies the name of the procedure, and its parameters.\n\n**Purpose** is a short textual description.\n\n**Type** specifies the types of the input parameters and of the returned value. \nThe types of number-valued and boolean-valued expressions are Number and Boolean, respectively.\nThe type of a procedure is denoted:\n\n```\n[(type of arg1) *...* (type of argn) \u2013> (return type)].\n```\n\n**Example** gives examples of procedure applications and their expected return values.\n\n**Pre-conditions** specify conditions that the input parameters are obliged to satisfy - beyond those expressed by the type.\n\n**Post-conditions** specify conditions that the returned value is responsible to satisfy.\n\n**Tests** provide test cases.\n\nFor important procedures, it is good practice to include all of these fields in the contract.\n\nFor **all** procedures, we require in all Scheme code produced in the class to have at least\nthese 3 components:\n```scheme\n; Signature: area-of-ring(outer,inner)\n; Purpose: To compute the area of a ring whose radius is\n;          \u2019outer\u2019 and whose hole has a radius of \u2019inner\u2019\n; Type: [Number*Number -> Number]\n```\n\nIf the pre-condition is not trivial (that is, always true), then you must specify it as well.\n\nFor example:\n\n```scheme\n; Signature: fact(n)\n; Type: [Number -> Number]\n; Purpose: compute the factorial of n.\n; Pre-conditions: n is a natural number\n; Tests:  (fact 5) => 120              \n(define fact \n  (lambda (n)\n    (if\t(= n 0)\n      1\n      (* n (fact (- n 1))))))\n```\n\nIf there are no pre-conditions, you should write `true`. \nThe programmer of the procedure should not check the pre-conditions - it is the responsibility of the client to make sure pre-conditions are met before calling the procedure.\n\nThe central idea of DbC is a metaphor on how elements of a software system collaborate\nwith each other, on the basis of mutual obligations and benefits. The metaphor comes\nfrom business life, where a client and a supplier agree on a contract. The contract defines\nobligations and benefits. If a routine provides a certain functionality, it may:\n* Impose a certain obligation to be guaranteed on entry by any client module that calls it: The routine\u2019s precondition \u2013 an obligation for the client, and a benefit for the supplier.\n* Guarantee a certain property on exit: The routine\u2019s post-condition is an obligation for the supplier, and a benefit for the client.\n* Maintain an invariant.\n\nThe contract is the formalization of these obligations and benefits.\n\nThe separation of responsibilities between caller and implementer of the procedures is:\n\n```\n---------------------------------------------------------------------\n            |          Client                       Supplier\n------------|--------------------------------------------------------\nObligation: | Guarantee precondition         Guarantee post-condition\nBenefit:    | Guaranteed post-condition      Guaranteed precondition\n---------------------------------------------------------------------\n```\n\n\n## Compound Types\n\nIn Scheme, we will use two compound types (others exist in Scheme, but we restrict ourselves to these 2 types):\n* Pair type\n* List type\n\n### Pair Type\n\nA pair value combines 2 values into a single unit.  \n\nFor values a (of type T1) and b (of type T2), we create a new value (of type Pair(T1,T2)) with the value constructor \"cons\":\n`(cons a b)`\n\nThe type of the return value is Pair(T1,T2). \n\nProcedures on the Pair type:\n\n* cons    Type: [T1 * T2 -> Pair (T1, T2)]\n* getters:\n  *     car:  Type:  [Pair(T1, T2) -> T1]\n  *     cdr:  Type:  [Pair(T1, T2) -> T2]\n* predicates:\n  *     pair?: Type: [Any -> Boolean]\n\nFor example:\n```scheme\n> (cons 1 #t)\n'(1 . #t)\n```\nThe type of the return value is Pair(Number,Boolean).\n\nNote: (cons 1 #t) is a syntactic form - the application of a primitive operator to 2 arguments - '(1 . 2) is the semantic value.\n\nScheme also provides a syntactic form to represent literal compound values of type Pair.\nIt is:\n```scheme\n'(1 . #t)  ;; starts with the quote symbol - followed by a parenthesis and `.` between the first and second member of the pair.\n```\n\nWhen a pair is embedded as the second member of a pair, the literal form in Scheme is changed.\n\n```scheme\n> (cons 1 (cons 2 3))\n;; instead of '(1 . (2 . 3)), it happens because DrRacket does not know\n;; if it prints pair of pairs or list (see later), until it's too late\n'(1 2 . 3)\n```\n\n### Box Representation - Pair and Cons-cells\n\nTraditionally, pairs are represented graphically as rectangles split in two halves.\nThese rectangles are called *cons cells* - they help understand the structure of compound recursive pair structures.\n\nFor people with C++ background, it helps to think of a cons-cell (a pair) as 2 pointers to other values.\n\n<big>Example 1:</big>\n```scheme\n> (cons 1 2)\n'(1 . 2)\n```\n\n![cons_cell1](./resources/ps3/PS3_img2.png)\n\n<big>Example 2:</big>\n```scheme\n> (cons 1 (cons 2 (lambda () (+ 1 2))))\n'(1 2 . #<procedure>)\n```\n![cons_cell2](./resources/ps3/PS3_img3.png)\n\nWe can use compound accessors to traverse recursive pairs.  \nThese are convenient abbreviations of combinations of `car` and `cdr`: the `cdd...dr` procedures (maximum 4-`d`):\n\n```scheme\n> (define c (cons 1 (cons 'cat (cons 3 (cons 4 5)))))\n> c\n'(1 cat 3 4 . 5)\n\n> (cdddr c)\n'(4 . 5)\n\n> (cdr (cdr (cdr c)))\n'(4 . 5)\n\n> (caddr c) ;; equivalent to (car (cdr (cdr c)))\n3\n```\n\n\n\n### List Type\n\nThe type List is defined inductively:\n* an empty list is a list - '() or (list)\n* a pair where the second argument is a list, is a list\n\nIt helps to define List(T) as Union(EmptyList, NEList(T)) [NEList(T) are the non empty list values]. It also helps to define heterogeneous lists types as Union(EmptyList, NEList) [NEList are the non empty heterogeneous list values].\n\nWe distinguish:\n* homogeneous list - all members are the same type T - List(T)\n* heterogeneous list - members with different types - List\n\n`list` - is a value constructor (to create a list). This procedure is a variadic (it can get any number of parameters).\nIn particular, (list) returns the empty list.\n\n`'()` also denotes the empty list.\n\n`cons` - is a value constructor too.\n\nList primitives:\n* list    Type: [T * T .... -> List(T)]\n* cons    Type: [T * List(T) -> NEList(T)]\n* getters:\n  *    car:    Type:  [NEList(T) -> T] \n  *    cdr:    Type:  [NEList(T) -> List(T)]\n* predicates:\n  *    list?:  Type:  [Any -> Boolean]\n  *    empty?: Type:  [Any -> Boolean]\n\nNOTE: We use the same `cons` primitive as for pairs - but we *think of it* as a primitive with a different type.\n\n\n```scheme\n> (list)\n'()\n\n> '()\n'()\n\n> (list 1 2)\n'(1 2)\n\n> (cons 1 2)\n'(1 . 2)\n\n> (list 1 2 3)\n'(1 2 3)\n\n> (cons 1 (cons 2 (cons 3 '())))\n'(1 2 3)\n```\n\n### Box Representation - List\n\n```scheme\n> (list (list 1 2) 1 2)\n'((1 2) 1 2)\n```\n![cons_cell3](./resources/ps3/PS3_img4.png)\n\n\n### Atomic / Compound Values and Equality Testing\n\nTo test whether 2 values are equal, there are multiple predicates in Scheme.\n* (= n1 n2) only works for numeric arguments.\n* (eq? v1 v2) - compares addresses \n* (equal? v1 v2) - compares values\n* There is no way to test that 2 functions are equal (why?)\n\n```scheme\n> (= 1 1)\n#t\n> (= 1 2)\n#f\n> (= #t #t)\n=: contract violation\n  expected: number?\n  given: #t\n  argument position: 1st\n  other arguments...:\n   #t\n> (eq? 1 1)\n#t\n> (eq? 1 2)\n#f\n> (eq? #t #t)\n#t\n> (eq? #t '(1 2))\n#f\n> (eq? '(1 2) '(1 2))\n#f\n> (define l12 (list 1 2))\n> (eq? l12 l12)\n#t\n> (equal? 1 1)\n#t\n> (equal? 3 3.0)\n#f\n> (equal? '(1 2) '(1 2))\n#t\n```\n\n\n### Structure of Procedures Operating on Lists\n\nThe general recipe for a procedure that operates on Lists follows the inductive definition of the type:\n\n```scheme\n(define <recipeOnList> \n  (lambda (listOfT)\n    (if (empty? listOfT)\n       ;; base case\n       do if true\n       ;; recursive case\n       do if false)))\n```\n\nLet us analyze examples of this recipe:\n\n<big>Question 1:</big> \n\nWrite the procedure `remove`:\n\n```scheme\n; Signature: remove(x lst)\n; Type: [T * List(T) -> List(T)]\n; Purpose: remove the first appearance of x in lst\n; Pre-conditions: true\n; Tests:  (remove 2 (list 1 3 2 2)) => '(1 3 2)\n(define remove\n  (lambda (x lst)\n    (if (empty? lst)\n        lst\n        (if (equal? (car lst) x)\n            (cdr lst)\n            (cons (car lst) (remove x (cdr lst)))))))\n```\n\n\n<big>Question 2:</big> \n\nWrite the procedure `remove-all`:\n\n```scheme\n; Signature: remove-all(x lst)\n; Type: [T * List(T) -> List(T)]\n; Purpose: remove all the occurrences of x in lst\n; Pre-conditions: true\n; Tests:  (remove-all 2 (list 1 3 2 2)) => '(1 3)\n(define remove-all\n  (lambda (x lst)\n    (if (empty? lst)\n        lst\n        (if (equal? (car lst) x)\n            (remove-all x (cdr lst))\n            (cons (car lst) (remove-all x (cdr lst)))))))\n```\n\n\nWe saw in the lecture the procedure `filter`:\n\n```scheme\n; Signature: filter(pred,lst)\n; Type: [ (T->Boolean) * List(T) -> List(T) ]\n; Purpose: Return the list of elements in lst that satisfy pred.\n(define filter\n  (lambda (pred lst)\n    (if (empty? lst)\n        '()\n        (if (pred (car lst))\n            (cons (car lst) (filter pred (cdr lst)))\n            (filter pred (cdr lst))))))\n```\n\n<big>Question 3:</big> Write the procedure `remove-all` using `filter`:\n\n```scheme\n; Signature: remove-all(x lst)\n; Type: [T * List(T) -> List(T)]\n; Purpose: remove the all appearances of x in lst\n; Pre-conditions: lst is a list\n; Tests:  (remove-all 2 (list 1 3 2 2)) => '(1 3)\n(define remove-all\n  (lambda (x lst)\n    (filter (lambda (y) (not (equal? x y)))\n            lst)))\n\n> (remove-all 1 '(1 2 1 3 1))\n'(2 3)\n> (remove-all '(a b) '((a 1) (a 2) (a b) (a 3) (a b)))\n'((a 1) (a 2) (a 3))\n```\n\n<big>Question 4:</big> Can we write the procedure `remove` using `filter`? \n\nNo - the decision implemented in filter is independent of the other decisions taken on the list.\nRemove requires us to take a different decision depending on the decisions already taken.\n\n\n<big>Question 5:</big> Write a procedure that finds a pair in a list of pairs by the value of the first element.\n\nLet us define a data type that is similar in functionally to Maps in JavaScript: a list of pairs.\nTraditionally, this is a called an *association list* in Scheme - or in short AList.\n\n```AList(T1, T2) = List(Pair(T1,T2))```\n\nWe think of an AList as a list of values of type T2 indexed by keys of type T1.\nFor example:\n```\n;; AList(Number,Number)\n'((1 . 10) (2 . 20) (3 . 30))\n\n;; AList(Boolean,Number)\n'((#t . 1) (#f . 0))\n```\n\n```scheme\n; Purpose: find a value in an AList given its key.\n; Signature: alist-get(alist, key)\n; Type: [AList(T1,T2) * T1 -> T2 | '()]\n(define alist-get\n  (lambda (alist key)\n    (if (empty? alist)\n        '()\n        (if (equal? (caar alist) key)\n            (cdar alist)\n            (alist-get (cdr alist) key)))))\n\n> (alist-get '((1 . 10) (2 . 20) (3 . 30)) 2)\n20\n\n> (alist-get '((1 . 10) (2 . 20) (3 . 30)) 0)\n'()\n```\n\nCan you define `alist-get` using filter?\n\n\n## Let Expression\n\nA `let` expression gives us the ability to define local variables.\n\n```scheme\n> (let ((a 5) (b 6))\n    (+ a b))\n11\n```\n\nBe careful that the values of the variables are computed **outside the scope of the variables**:\n\n```scheme\n> (let ((a 1) \n        (b (* a 3))) \n    (+ a b))\n\nError: a: undefined; cannot reference an identifier before its definition\n```\n\n## Iterative and Recursive Functions\n\nWe need to implement the function 'exp':\n```scheme\n; Signature: exp(b e) \n; Type: [Number * Number -> Number] \n; Purpose: to calculate b to the power e. \n; Pre-conditions: b >= 0, e is natural. \n; Tests: (exp 2 3) => 8\n;        (exp 2 4) => 16\n;        (exp 3 4) => 81\n```\n\n<big>Question 1:</big> write a recursive version\n\n```scheme\n(define exp \n    (lambda (b e) \n       (if (zero? e) \n           1\n           (* b (exp b (- e 1))))))\n```\n\n\n<big>Question 2:</big> write an iterative version of exp\n\n```scheme\n;; Purpose: compute b^e in an iterative manner\n;; Signature: exp-iter(b,e,1)\n;; Type: [Number * Number * Number -> Number]\n;; Pre-conditions: e is a natural number\n;; Example: (exp-iter 2 10 1) => 1024\n(define exp-iter\n    (lambda (b e acc) \n       (if (zero? e) \n           acc\n           (exp-iter b (- e 1) (* b acc)))))\n```\n\nThis version is iterative because the call to exp-iter is in tail position.\n\nIt is a different algorithm than the one shown above.\n\nWe can use the `trace` function of Racket to see exactly how a recursive function runs vs. an iterative function:\n\n```scheme\n(require racket/trace)\n\n(define exp ...)\n(define exp-iter ...)\n\n(trace exp)\n(trace exp-iter)\n```\n\n```scheme\n> (exp 2 5)\n>(exp 2 5)\n> (exp 2 4)\n> >(exp 2 3)\n> > (exp 2 2)\n> > >(exp 2 1)\n> > > (exp 2 0)\n< < < 1\n< < <2\n< < 4\n< <8\n< 16\n<32\n32\n\n> (exp-iter 2 5 1)\n>(exp-iter 2 5 1)\n>(exp-iter 2 4 2)\n>(exp-iter 2 3 4)\n>(exp-iter 2 2 8)\n>(exp-iter 2 1 16)\n>(exp-iter 2 0 32)\n<32\n32\n```\n\nWe can see in the call to `exp` that we need to keep track of the previous stack frames, which creates a \"pyramid\" stack trace. This is in contrast to the iterative `exp-iter` which creates a linear stack trace.\n\n<big>Question 3:</big> write an iterative version\n\n```scheme\n\n;; secondary function\n(define exp$ \n(lambda (b e delayed)\n   (if (zero? e) \n       (delayed 1)\n       (exp$ b (- e 1)\n            (lambda (res-e-1) (delayed (* res-e-1 b)))))))\n\n\n;; the main function\n(define exp \n (lambda (b e)\n    (exp$ b e (lambda (x) x))))\n\n```\n\nWhy is `exp$` considered iterative? because the last call is `exp$`.\n"
    },
    {
        "name": "Lesson 4 - Concrete and Abstract Syntax",
        "content": "# Concrete and Abstract Syntax\n\n## Practical Session - Week 4 PPL@BGU\n\n\nIn this session, we review:\n* Syntax: Concrete vs Abstract\n* Parsing S-Exp (Symbol Expressions) into Scheme expressions (add syntactic description for cond expressions)\n* Rewriting ASTs to derive one syntactic construct into another (if into cond)\n* Parsing a stream of Tokens into S-Exp\n\n## Syntax: Concrete vs Abstract\n\nProgramming languages have two aspects of syntax: concrete and abstract. While the concrete syntax is part of the definition of the language, the abstract syntax is part of the definition of a particular implementation of a language (interpreter or compiler).\n\n**Concrete Syntax**\n\nThe concrete syntax a programming language consists of a set of rules that determine how programs look like to the programmer. That is, it is intended to be read by humans. The rules are specified formally using a Backus-Naur Form (BNF) and include language keywords, delimiters, parentheses, etc.\n\nThe formal specification includes two types of rules:\n\n* Lexical rules: determine how to tokenize sequences of characters into significant language tokens. The program which performs this operation is called scanner.\n* Syntactic rules: determine how to combine tokens into hierarchical structures which form language expressions. This work is done by a parser.\n\n**Abstract Syntax**\n\nThe abstract syntax of a programming language defines how programs look like to the interpreter or compiler. Abstract syntax defines a data type. The values of this data type are called abstract syntax trees (AST). These values are used to represent expressions so that they can be easily processed by meta-programs (interpreter or compiler).\n\nAbstract syntax defines:\n\n* Alternative kinds for expression categories (e.g., kinds of if-expressions),\n* The components of composite elements (as well as the role, the category, and cardinality of each component).\n\n## Formal definition\n\nTo define formally the syntax of Scheme, we adopt the notation below. This notation combines both the concrete syntax syntactic rules as BNF notation and for each rule, the corresponding abstract syntax type.\n\n```scheme\n;; <program> ::= (L1 <exp>+) // program(exps:List(exp))\n;; <exp> ::= <define-exp> | <cexp>\n;; <define-exp> ::= (define <var-decl> <cexp>) // def-exp(var:var-decl, val:cexp)\n;; <cexp> ::= <num-exp> // num-exp(val:Number)\n;;        | <bool-exp>  // bool-exp(val:Boolean)\n;;        | <prim-op>   // prim-op(op:string)\n;;        | <var-ref>   // var-ref(var:string)\n;;        | (<cexp> <cexp>*) // app-exp(rator:cexp, rands:List(cexp))\n;; <prim-op> ::= + | - | * | / | < | > | = | not\n;; <num-exp> ::= a number token\n;; <bool-exp> ::= #t | #f\n;; <var-ref> ::= an identifier token\n;; <var-decl> ::= an identifier token // var-decl(var:string)\n```\n\nThe following diagram illustrates the steps through which a program is processed until it is evaluated by an interpreter. We focus in this session on Scanning and Parsing.\n\n\n![eval_process](./resources/ps4/eval_process.jpg)\n\n\n# Parsing a program string into S-Exp\n\n\nSince Scheme is a language that is based on a general structure called the S-Expression (in short [S-exp](https://en.wikipedia.org/wiki/S-expression)), we will take a \"shortcut\" approach to transform our program as string to significant hierarchical structures.\nThis work will be done by an existing Node parser for S-Exp. Make sure you install it in your parser folder by running the command `npm install s-expression --save`.\n\nBecause the function \"s-expression\" exposes can return an error for incorrect inputs (such as `\"(+ 1\"`), we wrap s-expression's function in a function that returns a `Result<Sexp>` (more on `Result<T>` later).\n\nFor example\n\n```typescript\nimport { parse as parseSexp } from \"../shared/parser\";\n \nparseSexp(\"1\"); // { tag: 'Ok', value: '1' }\nparseSexp(\"(1 2)\"); // { tag: 'Ok', value: [ '1', '2' ] }\nparseSexp(\"(+ 1 (* 2 3))\"); // { tag: 'Ok', value: [ '+', '1', [ '*', '2', '3' ] ] }\nparseSexp(\"(define x 5)\"); // { tag: 'Ok', value: [ 'define', 'x', '5' ] }\n```\n\nTherefore, the scanner in our course is not implemented by us, but by this ready-to-import Node module. This is possible since the language's concrete syntax is fairly simple, and thus S-Exps provide a sound basis.\n\nThe BNF of S-Exps is the following:\n\n```scheme\n;; <S-exp> ::= <AtomicSexp> | <CompoundSexp>              // Sexp\n;; <AtomicSexp> ::= <number> | <boolean> | <string>       // Token\n;; <CompoundSexp> ::= '(' <S-exp>* ')                     // CompoundSexp\n```\n\nThe TypeScript type definition returned by the S-Exp parser was presented in lectures:\n\n```typescript\ndeclare module 's-expression' {\n    export type SexpString = String;\n    export type Token = string | SexpString;\n    export type CompoundSexp = Sexp[];\n    export type Sexp = Token | CompoundSexp;\n \n    /*\n        The types returned by the parser are:\n        string - for any token which is not a string,\n                 according to the tokenization rules of S-expressions.\n        SexpString - for tokens of the form \"...\"\n        Sexp[] - for S-expressions that contain sub-expressions\n                 (of the form \"(<s-expr1> ... <s-exprn>)\")\n    */\n    export default function parse(x: string): Sexp;\n}\n```\n\n\n## Parsing S-Exp into ASTs\n\nWe implement a parser in TypeScript that takes the output of the S-Exp parser and transforms it into ASTs of our language, as defined in the BNF above.\nFor example:\n\n```typescript\nbind(parseSexp(\"1\"), parseL1Exp);\n// Output: \n{ tag: 'Ok', value: { tag: 'NumExp', val: 1 } }\n```\n\n```typescript\nbind(parseSexp(\"#t\"), parseL1Exp);\n// Output:\n{ tag: 'Ok', value: { tag: 'BoolExp', val: true } }\n```\n\n```typescript\nbind(parseSexp(\"(define x 1)\"), parseL1Exp);\n// Output:\n{ tag: 'Ok',\n  value: { tag: 'DefineExp',\n           var: { tag: 'VarDecl', var: 'x' },\n           val: { tag: 'NumExp', val: 1 } } }\n```\n\n```typescript\nbind(parseSexp(\"(> x 1)\"), parseL1Exp);\n// Output:\n{ tag: 'Ok',\n  value: { tag: 'AppExp',\n           rator: { tag: 'PrimOp', op: '>' },\n           rands: [ { tag: 'VarRef', var: 'x' }, { tag: 'NumExp', val: 1 } ] } }\n```\n\n```typescript\n// More examples - write the JSON values you expect to be returned by the parser:\nbind(parseSexp(\"(> (+ x x) (* x x))\"), parseL1Exp);\n \nbind(parseSexp(\"(L1 (define x 1) (> (+ x 1) (* x x)))\"), parseL1Exp);\n```\n\n* Notice how parsing S-Exps into ASTs removes details from the concrete syntax.\n* The result ASTs are data values that can be easily processed by the interpreter.\n* Parsing into AST is a step performed for all programming languages. This online tool helps you explore the ASTs of many languages: [astexplorer.net](https://astexplorer.net). Note how these ASTs are often complex, because these languages (JavaScript, SQL etc) have a more complex syntax than Scheme.\n\n\n## Implementing ASTs in TypeScript for Scheme\n\nASTs are types that follow the Disjoint Union Types pattern. We implement such types in TypeScript using tagged maps and unions. Similarly, in Java, we would implement ASTs by defining a new class. This class would includes a constructor and all relevant procedures and would allow us to conveniently manipulate data values of the type we introduced.\n\nIn TypeScript, we can introduce Disjoint Union data types according to the following recipe:\n\n* A constructor function named make and which takes as parameters each of the component values of the compound type\n* A type predicate function named is.\n\n**For example:**\n```typescript\nexport type NumExp = {tag:\"NumExp\", val:number}; // The Num-Expression type\nexport const makeNumExp = (n: number):NumExp => ({tag:\"NumExp\", val:n}); // The value constructor for Num-Expression\nexport const isNumExp = (x:any): x is NumExp => x.tag === 'NumExp'; // The type predicate function of Num-Expression\n```\n\n**Remarks:**\n\n* Notice the keyword export which allows the type/function to be imported into other modules where it is needed (by using the keyword import) such as the interpreter.\n* Notice as well the type expression x is NumExp which is Boolean. This type expression implies that the function isNumExp is actually a type predicate. Due to these kinds of type expressions that yield type predicates the type checker can do precise inference. As an example:\n\n```typescript\ndescribe(\"L1 Parsing\", () => {\n  it(\"parses AppExps correctly\", () => {\n    const result = bind(parseSexp(\"(> 1 2)\"), parseL1CExp);\n    if (isOkT(isAppExp)(result)) {\n      // With the type predicate isAppExp, the type checker infers\n      // that in this scope \"result.value\" is exactly of type AppExp\n      // so it is safe to access properties that only exist on AppExp\n      expect(result.value.rator).to.deep.equal(makePrimOp(\">\"));\n    }\n  });\n});\n```\n\nThe type of `result` at line 3 is the type of the return value of `parseL1CExp` which is `Result<NumExp | BoolExp | PrimOp | VarRef | AppExp>`. However, because `isAppExp` is a type predicate with return type `x is AppExp`, the type checker infers that `result.value` inside the scope of line 8 is exactly of the type `AppExp` and not the disjunction type `NumExp | BoolExp | PrimOp | VarRef | AppExp`.\n\n\nA disjoint union type construct has the following shape: `type CExp = NumExp | BoolExp | PrimOp | VarRef | AppExp;` which is a union of disjoint types. Each disjoint type is defined as a tagged map. We use the convention of using the key \"tag\" to enforce the disjointness of these types. Any other key could be used, but we use this one consistently to express our intention of defining disjoint types. There is a constructor function for each disjoint type, but none for the union type. In this sense, we understand that the union type is a sort of abstract type over the disjoint types.\n\n\nC-Exp (short for constituent expression \u2013 expression classes that can be part of a bigger one), has the following BNF:\n\n```typescript\n<cexp> ::= <num-exp> // num-exp(val:Number)\n       | <bool-exp>  // bool-exp(val:Boolean)\n       | <prim-op>   // prim-op(op:string)\n       | <var-ref>   // var-ref(var:string)\n       | (<cexp> <cexp>*) // app-exp(rator:cexp, rands:List(cexp))\n```\n\n**Question**: why are `define` expressions not considered constituent?\n\n**Answer**: if they were constituent, they would appear in the `cexp` BNF, which means that they may be nested, but we disallow nesting of `define` expressions in our course. Define can only appear at the top level of programs.\n\n\nA union type is abstract - which means it has no constructor (there are no values of type Exp - Exp is the union of concrete types). It still has a type predicate - which simply tests that a value belongs to one of the disjoint types:\n\n```typescript\nexport const isExp = (x: any): x is Exp => isDefineExp(x) || isCExp(x);\nexport const isCExp = (x: any): x is CExp => isNumExp(x) || isBoolExp(x) || isPrimOp(x) ||\nisVarRef(x) || isAppExp(x);\n```\n\n\n## Implementing the Parser\n\nThe following set of functions implement the parser.\n Parsing (which includes using the \"shortcut\" scanner) a program starts by a call to the function `parseL1` by giving it our program as string. For example, by calling `parseL1(\"(L1 (define x 5) (+ x 6))\")`. Note that there are a few helpful functions we have omitted here, such as `isEmpty,isArray,isString`.\n\n```typescript\nimport { Sexp, Token } from \"s-expression\";\nimport { parse as parseSexp, isToken, isCompoundSexp } from \"../shared/parser\";\nimport { all, find } from 'ramda';\nimport { format } from '../shared/format';\n\n// combine Sexp parsing with the L1 parsing\nexport const parseL1 = (x: string): Result<Program> =>\n    bind(parseSexp(x), parseL1Program);\n\n// L1 concrete syntax\n// <Program> -> (L1 <Exp>+)\n// <Exp> -> <DefineExp> | <CExp>\n// <DefineExp> -> (define <varDecl> <CExp>)\n// <CExp> -> <AtomicExp> | <AppExp>\n// <AtomicExp> -> <number> | <boolean> | <primOp>\n// <AppExp> -> (<CExp>+)\n\n// <Program> -> (L1 <Exp>+)\nexport const parseL1Program = (sexp: Sexp): Result<Program> =>\n    sexp === \"\" || isEmpty(sexp) ? makeFailure(\"Unexpected empty program\") :\n    isToken(sexp) ? makeFailure(`Program cannot be a single token: ${sexp}`) :\n    isCompoundSexp(sexp) ? \n        isNonEmptyList<Sexp>(sexp) ? parseL1GoodProgram(first(sexp), rest(sexp)) : \n        makeFailure(`Program cannot be a list of a single token: ${sexp}`) :\n    sexp;\n\nconst parseL1GoodProgram = (keyword: Sexp, body: Sexp[]): Result<Program> =>\n    keyword === \"L1\" && !isEmpty(body) ? mapv(mapResult(parseL1Exp, body), (exps: Exp[]) => \n                                              makeProgram(exps)) :\n    makeFailure(`Program must be of the form (L1 <exp>+): ${format(keyword)}`);\n\n// Exp -> <DefineExp> | <Cexp>\n// <Sexp> = <CompoundSexp> | <Token>\nexport const parseL1Exp = (sexp: Sexp): Result<Exp> =>\n    isEmpty(sexp) ? makeFailure(\"Exp cannot be an empty list\") :\n    isCompoundSexp(sexp) ? \n        isNonEmptyList<Sexp>(sexp) ? parseL1CompoundExp(first(sexp), rest(sexp)) :\n        makeFailure(`Exp cannot be a list of single token: ${sexp}`) :\n    isToken(sexp) ? parseL1Atomic(sexp) :\n    sexp;\n    \n// Compound -> DefineExp | CompoundCExp\nexport const parseL1CompoundExp = (op: Sexp, params: Sexp[]): Result<Exp> => \n    op === \"define\"? parseDefine(params) :\n    parseL1CompoundCExp(op, params);\n\n// CompoundCExp -> AppExp\nexport const parseL1CompoundCExp = (op: Sexp, params: Sexp[]): Result<CExp> =>\n    parseAppExp(op, params);\n\n// DefineExp -> (define <varDecl> <CExp>)\nexport const parseDefine = (params: List<Sexp>): Result<DefineExp> =>\n    isNonEmptyList<Sexp>(params) ?\n        isEmpty(rest(params)) ? makeFailure(`define missing 1 arguments: ${format(params)}`) :\n        (params.length > 2) ? makeFailure(`define has too many arguments: ${format(params)}`) :\n        parseGoodDefine(first(params), second(params)) :\n    makeFailure(`define missing 2 arguments: ${format(params)}`);\n\nconst parseGoodDefine = (variable: Sexp, val: Sexp): Result<DefineExp> =>\n    ! isIdentifier(variable) ? makeFailure(`First arg of define must be an identifier: ${format(variable)}`) :\n    mapv(parseL1CExp(val), (value: CExp) => \n         makeDefineExp(makeVarDecl(variable), value));\n\n// CExp -> AtomicExp | CompondCExp\nexport const parseL1CExp = (sexp: Sexp): Result<CExp> =>\n    isCompoundSexp(sexp) ?\n        isNonEmptyList<Sexp>(sexp) ? parseL1CompoundCExp(first(sexp), rest(sexp)) :\n        makeFailure(`L1CExp cannot be an empty list`) :\n    isToken(sexp) ? parseL1Atomic(sexp) :\n    sexp;\n\n// Atomic -> number | boolean | primitiveOp\nexport const parseL1Atomic = (token: Token): Result<CExp> =>\n    token === \"#t\" ? makeOk(makeBoolExp(true)) :\n    token === \"#f\" ? makeOk(makeBoolExp(false)) :\n    isString(token) && isNumericString(token) ? makeOk(makeNumExp(+token)) :\n    isString(token) && isPrimitiveOp(token) ? makeOk(makePrimOp(token)) :\n    isString(token) ? makeOk(makeVarRef(token)) :\n    makeFailure(`Invalid atomic token: ${token}`);\n\nexport const isPrimitiveOp = (x: string): boolean =>\n    [\"+\", \"-\", \"*\", \"/\", \">\", \"<\", \"=\", \"not\"].includes(x)\n\n// AppExp -> ( <cexp>+ )\nexport const parseAppExp = (op: Sexp, params: Sexp[]): Result<CExp> =>\n    bind(parseL1CExp(op), (rator: CExp) =>\n         mapv(mapResult(parseL1CExp, params), (rands: CExp[]) =>\n              makeAppExp(rator, rands)));\n```\n\n## Using the Result Type for Error Processing\n\n The parser can result either a \"good value\" or an error when the input string does not belong to the language specified by the concrete syntax. To ease error handling, we use the `Result<T>` monad introduced in Assignment 1. A result is a disjoint union between an OK type `Ok<T>` and the Failure type which is returned in case of errors.\n\nThe benefit of using Result systematically in the code is that it allows us to write code mainly as the \"happy path\" \u2013 only write what happens when there are no errors. When functions return Result values, they can be composed using the `bind` operator - for example:\n\n```typescript\nbind(mapResult(parseL1Exp, body),\n     (exps: Exp[]) => makeOk(makeProgram(exps)))\n```\n\nWithout error handling, this code would be written as a simple composition:\n\n```typescript\n// Types: body: Sexp[];\n//        parseL1Exp: Sexp => Exp\n//        makeProgram: Exp[] => Program\nmakeProgram(map(parseL1Exp, body))\n```\n\nIn this call, `parseL1Exp` can return either an Exp or a Failure for each element - hence it would be unsafe to write this simple composition. For simple functions, we test for errors and return a Failure value or else return an ok value - for example:\n\n```typescript\n// Atomic -> number | boolean | primitiveOp\nexport const parseL1Atomic = (token: Token): Result<CExp> =>\n    token === \"#t\" ? makeOk(makeBoolExp(true)) :\n    ...\n    makeFailure(\"Invalid atomic token: \" + token);\n```\n\nTo compose functions that return a Result, we use the following Result-helper functions:\n\n* `bind`\n* `mapResult`\n\n```typescript\n// Instead of f2(f1(x)) - we write:\nbind( <f1 returns a Result<T>>, \n      (y: T) => <f2 receives the result of f1 if it is ok> );\n```\n\nbind is used to chain calls of functions that return Result.\n\n* Note that the order in which the functions appear in a bind is the order in which the functions are executed (`f1` then `f2`) - and not as in `f2(f1(x))` where the order is reversed (`f2` then `f1`).\n* The second function in the chain receives a `T` parameter and not a `Result<T>` parameter - because it is only invoked when the call to `f1(x)` succeeds. When the call to `f1(x)` fails, `f2` is not invoked.\n\n`mapResult` is used to apply a function that returns a `Result<T>` to an array of `T` values (`T[]`):\n\n```typescript\nmapResult(f:(x: T1) => Result<T2>, arr: T1[]) => Result<T2[]>\n```\n\nIt is used exactly like the traditional `map` function, but if `f` fails on any one of the items in `arr`, then the function fails and returns the first Failure value - else it returns a `Result<T2[]>` (and not an array of Result values).\n\n\n\n## Supporting `if` expressions\n\nRecall that `if` expressions have the form `(if <test> <then> <else>)`. We would like our parser to support these expressions.\n\n## Adding if to the concrete and abstract syntax\n\nIn order to add if in the concrete and abstract syntax, we must modify the syntactic rules we presented earlier as a BNF notation.\n\n**Note:** Our modification of the concrete will determine how a if expression will look like to the programmer. This requires placing punctuation. Our modification of the abstract syntax will determine how the parser will transform if expressions into ASTs. The modified concrete and abstract syntax follows:\n\n```typescript\n<cexp> ::= <num-exp>               // num-exp(val:Number)\n       | <bool-exp>                // bool-exp(val:Boolean)\n       | <prim-op>                 // prim-op(op:string)\n       | <var-ref>                 // var-ref(var:string)\n       | (if <cexp> <cexp> <cexp>) // if-exp(test:cexp, then:cexp, else:cexp)\n       | (<cexp> <cexp>*)          // app-exp(rator:cexp, rands:List(cexp))\n```\n\n## Modifying the parser to support *if* expressions\n\n\n**Step-1**: We add a new type definition for if ASTs\n\n```typescript\n// Type definitions\nexport type IfExp = { tag: \"IfExp\"; test:CExp; then: CExp; alt: CExp; };\n// Value constructors\nexport const makeIfExp = (test: CExp, then: CExp, alt: CExp): IfExp =>\n    ({ tag: \"IfExp\", test: test, then: then, alt: alt }); \n// Type predicates:\nexport const isIfExp = (x: any): x is IfExp => x.tag === \"IfExp\";\n```\n\n**Step-2**: Update the cexp disjoint union type\n\n```typescript\nexport type CExp = NumExp | BoolExp | PrimOp | VarRef | IfExp | AppExp;\nexport const isCExp = (x: any): x is CExp => isNumExp(x) || isBoolExp(x) || isPrimOp(x) ||\n    isVarRef(x) || isIfExp(x) ||  isAppExp(x);\n```\n\n**Step-3**: Modify the relevant functions\n\n```typescript\n// CompoundCExp -> IfExp | AppExp\nexport const parseL1CompoundCExp = (op: Sexp, params: Sexp[]): Result<CExp> =>\n    op === \"if\" ? parseIfExp(params) :\n    parseAppExp(op, params);\n \n// IfExp -> (if <CExp> <CExp> <CExp>)\nexport const parseIfExp = (params: Sexp[]): Result<IfExp> =>\n    params.length !== 3 ? makeFailure(\"Incorrect number of expressions in if\") :\n    bind(mapResult(parseL1CExp, params),\n         (cexps: CExp[]) => makeOk(makeIfExp(cexps[0], cexps[1], cexps[2])));\n```\n\n**Example:**\n\n```typescript\n// Scanning and reading (ie string -> S-Exp)\nparseSexp(\"(if (= x 5) #t (* x x))\");\n// Output:\n{ tag: 'Ok', value: [ 'if', [ '=', 'x', '5' ], '#t', [ '*', 'x', 'x' ] ] }\n```\n\n```typescript\n// Parsing into AST:\nconst myIfExp = bind(parseSexp(\"(if (= x 5) #t (* x x))\"), parseL1Exp);\nconsole.log(JSON.stringify(myIfExp, null, 2))\n// Output:\n{\n  \"tag\": \"Ok\",\n  \"value\": {\n    \"tag\": \"IfExp\",\n    \"test\": {\n      \"tag\": \"AppExp\",\n      \"rator\": {\n        \"tag\": \"PrimOp\",\n        \"op\": \"=\"\n      },\n      \"rands\": [\n        {\n          \"tag\": \"VarRef\",\n          \"var\": \"x\"\n        },\n        {\n          \"tag\": \"NumExp\",\n          \"val\": 5\n        }\n      ]\n    },\n    \"then\": {\n      \"tag\": \"BoolExp\",\n      \"val\": true\n    },\n    \"alt\": {\n      \"tag\": \"AppExp\",\n      \"rator\": {\n        \"tag\": \"PrimOp\",\n        \"op\": \"*\"\n      },\n      \"rands\": [\n        {\n          \"tag\": \"VarRef\",\n          \"var\": \"x\"\n        },\n        {\n          \"tag\": \"VarRef\",\n          \"var\": \"x\"\n        }\n      ]\n    }\n  }\n}\n```\n\n\n## Supporting `cond` expressions\n\n* We want our parser to support cond expressions.\n* A cond expression is of the form `(<cond> (<cond-clause> ...))`\n* Where each is either of the form `(<test> <then>)` or `(else <then>)`\n\n**For example:**\n\n```typescript\n(define fib (lambda (n)\n               (cond ((= n 0) 0)\n                     ((= n 1) 1)\n                     (else (+ (fib (- n 1)) \n                              (fib (- n 2)))))))\n```\n\nPay attention! `cond` is a \"special form\": it is a compound expression which is not evaluated like regular (application) compound expressions.\n\n\n## Computation Rule for `(cond (cond-clause \u2026))`\n\n1. Compute the expression in the first\n2. If the value is not `#f`, compute the expression\n3. Otherwise, continue with the next expression\n4. If all expressions evaluate to `#f`, return the value of the last expression (the \"else clause\").\n\n\n## Adding cond in the concrete and abstract syntax\n\n```typescript\n<cexp> ::= <num-exp>                // num-exp(val:Number)\n       | <bool-exp>                 // bool-exp(val:Boolean)\n       | <prim-op>                  // prim-op(op:string)\n       | <var-ref>                  // var-ref(var:string)\n       | (if <cexp> <cexp> <cexp>)  // if-exp(test:cexp, then:cexp, else:cexp)\n       | (cond <cond-clauses>*)     // cond-exp(cond-clauses:List(cond-clause))\n       | (<cexp> <cexp>*)           // app-exp(rator:cexp, rands:List(cexp))\n<cond-clause> ::= (<cexp> <cexp>+)  // cond-clause(test:cexp, then:List(cexp))\n                  |  (else <cexp>+ )\n```\n\n\n## Modifying the parser to support cond expressions\n\n**Step-1**: We add a new type definition for cond ASTs\n\n```typescript\n// Type definitions\nexport type CondClause = { tag: \"CondClause\", test: CExp, then: CExp[]; }\nexport type CondExp = { tag: \"CondExp\", condclauses: CondClause[]; }\n// Value constructors\nexport const makeCondClause = (test: CExp, then: CExp[]) : CondClause =>\n    ({ tag: \"CondClause\", test: test, then: then });\nexport const makeCondExp = (condclauses: CondClause[]) : CondExp =>\n    ({ tag: \"CondExp\", condclauses: condclauses });\n// Type predicates:\nexport const isCondClause = (x:any): x is CondClause => x.tag === \"CondClause\";\nexport const isCondExp = (x:any): x is CondExp => x.tag === \"CondExp\";\n```\n\n**Step-2**: Update the cexp disjoint union type\n\n```typescript\nexport type CExp = NumExp | BoolExp | PrimOp | VarRef | IfExp | CondExp | AppExp;\nexport const isCExp = (x: any): x is CExp => isNumExp(x) || isBoolExp(x) || isPrimOp(x) ||\n    isVarRef(x) || isIfExp(x) || isCondExp(x) || isAppExp(x);\n```\n\n**Step-3**: Modify the relevant functions\n\n```typescript\n// CompoundCExp -> IfExp | CondExp | AppExp\nexport const parseL1CompoundCExp = (op: Sexp, params: Sexp[]): Result<CExp> =>\n    op === \"if\" ? parseIf(params) :\n    op === \"cond\" ? parseCond(params) :\n    parseAppExp(op, params);\n \n// CondExp -> (cond (<CExp> <CExp>+)+)\nexport const parseCondExp = (params: Sexp[]): Result<CondExp> => {\n    if (!allT(isCompoundSexp, params)) {\n        return makeFailure(\"Invalid cond clauses\");\n    } else {\n        const clausesResult = mapResult((clause: Sexp[]) =>\n            safe2((test: CExp, then: CExp[]) => makeOk(makeCondClause(test, then)))\n                 (parseL1CExp(first(clause)), mapResult(parseL1CExp, rest(clause))), params);\n        return bind(clausesResult, (clauses: CondClause[]) => makeOk(makeCondExp(clauses)));\n    }\n}\n```\n\n**Example:**\n\n```typescript\n// Scanning and reading (ie string -> S-Exp)\nparseSexp(\"(cond (1 1) (else 3))\");\n// Output:\n{ tag: 'Ok', value: [ 'cond', [ '1', '1' ], [ 'else', '3' ] ] }\n```\n\n```typescript\nconst myCondExp = bind(parseSexp(\"(cond (1 1) (else 3))\"), parseL1Exp);\nconsole.log(JSON.stringify(myCondExp, null, 2))\n \n// Output:\n{\n  \"tag\": \"Ok\",\n  \"value\": {\n    \"tag\": \"CondExp\",\n    \"condClauses\": [\n      {\n        \"tag\": \"CondClause\",\n        \"test\": {\n          \"tag\": \"NumExp\",\n          \"val\": 1\n        },\n        \"then\": [\n          {\n            \"tag\": \"NumExp\",\n            \"val\": 1\n          }\n        ]\n      },\n      {\n        \"tag\": \"CondClause\",\n        \"test\": {\n          \"tag\": \"VarRef\",\n          \"var\": \"else\"\n        },\n        \"then\": [\n          {\n            \"tag\": \"NumExp\",\n            \"val\": 3\n          }\n        ]\n      }\n    ]\n  }\n}\n```\n\n\n## Remarks:\n\n1. Note how the parser referred to `else` as a VarRef. This would raise an error when the interpreter processes the AST, as it will look for the value bound to `else`.\n2. The \"else-clause\" should only occur as last clause in a cond expression. One way to enforce this is to change the syntax from:\n\n```typescript\n;; ( cond <cond-clause>* )                 / cond-exp(cond-clauses:List(cond-clause))\n```\n\nto: \n\n```typescript\n;; ( cond <cond-clause>* <else-clause>? )  / cond-exp(cond-clauses:List(cond-clause))\n```\n\nThis means that cexps can now include the token 'else`, which should be addressed by the parser. The question is: what is the corresponding AST that the parser should generate?\n\n1. We could leave abstract syntax as `List(cond-clauses)`, and parse an else-clause to #t.\n2. Or, we could change the abstract syntax to `cond-clauses:List(cond-clause), else-clause: else-clause` and leave handling else-clause to the interpreter.\n\nThe first option is preferable as it keeps the interpreter more simple.\n\n\n## Rewriting If-exp ASTs into Cond-exp ASTs\n\n\nIf we consider the evaluation rule of if-exp ASTs and that of cond-exp ASTs, we observe that they could be reduced to equivalent forms. We could either rewrite if-exp into cond-exp or vice-versa.\n\nWhen we apply such syntactic reduction (one form into another), we reduce the complexity of the operational semantics - since we only need to provide one evaluation rule for the two syntactic forms.\n\nLet us illustrate how we map ASTs that contain if-exps into semantically equivalent ASTs that contain only cond-exp.\n\nThe basic rewriting step is to convert:\n\n```typescript\n(if <test> <then> <else>)\n```\n\ninto: \n\n```typescript\n(cond (<test> <then>)\n      (else <else>))\n```\n\n```typescript\n// Rewrite a single if expression as a semantically equivalent\n// cond-exp form\nconst rewriteIf = (exp: IfExp): CondExp =>\n    makeCondExp([\n        makeCondClause(exp.test, [exp.then]),\n        makeCondClause(makeBoolExp(true), [exp.alt])\n    ]);\n```\n\nExample:\n\n```typescript\nlet myIfExp = bind(parseSexp(\"(if 1 2 3)\"), parseL1Exp);\nif (isOkT(isIfExp)(myIfExp)) {\n    console.log(JSON.stringify(bind(myIfExp, exp => makeOk(rewriteIf(exp))), null, 2));\n}\n \n// Output:\n{\n  \"tag\": \"Ok\",\n  \"value\": {\n    \"tag\": \"CondExp\",\n    \"condClauses\": [\n      {\n        \"tag\": \"CondClause\",\n        \"test\": {\n          \"tag\": \"NumExp\",\n          \"val\": 1\n        },\n        \"then\": [\n          {\n            \"tag\": \"NumExp\",\n            \"val\": 2\n          }\n        ]\n      },\n      {\n        \"tag\": \"CondClause\",\n        \"test\": {\n          \"tag\": \"BoolExp\",\n          \"val\": true\n        },\n        \"then\": [\n          {\n            \"tag\": \"NumExp\",\n            \"val\": 3\n          }\n        ]\n      }\n    ]\n  }\n}\n```\n\nWe then need to make sure we transform all if-exp nodes in an AST wherever they occur. So we must rewrite all `if` expressions wherever the language permits their appearance.\n\n```typescript\nconst rewriteAllIf = (e: CExp): CExp =>\n    isBoolExp(e) ? e :\n    isNumExp(e) ? e :\n    isPrimOp(e) ? e :\n    isVarRef(e) ? e :\n    isVarDecl(e) ? e :\n    isIfExp(e) ?  rewriteIf(makeIfExp(rewriteAllIf(e.test),\n                                      rewriteAllIf(e.then),\n                                      rewriteAllIf(e.alt))) :\n    isCondExp(e) ? makeCondExp(\n        map(clause => makeCondClause(rewriteAllIf(clause.test),\n                                     map(rewriteAllIf, clause.then)),\n            e.condClauses)) :\n    isAppExp(e) ? makeAppExp(rewriteAllIf(e.rator), map(rewriteAllIf, e.rands)) :\n    e;\n```\n\nExample:\n\n```typescript\nconst rewrittenIf = bind(\n  bind(parseSexp(\"(if (= 3 2) 5 (if (= 3 3) 12 27))\"), parseL1CExp),\n  exp => makeOk(rewriteAllIf(exp))\n);\nconsole.log(JSON.stringify(rewrittenResult, null, 2));\n \n// Output:\n{\n  \"tag\": \"Ok\",\n  \"value\": {\n    \"tag\": \"CondExp\",\n    \"condClauses\": [\n      {\n        \"tag\": \"CondClause\",\n        \"test\": {\n          \"tag\": \"AppExp\",\n          \"rator\": {\n            \"tag\": \"PrimOp\",\n            \"op\": \"=\"\n          },\n          \"rands\": [\n            {\n              \"tag\": \"NumExp\",\n              \"val\": 3\n            },\n            {\n              \"tag\": \"NumExp\",\n              \"val\": 2\n            }\n          ]\n        },\n        \"then\": [\n          {\n            \"tag\": \"NumExp\",\n            \"val\": 5\n          }\n        ]\n      },\n      {\n        \"tag\": \"CondClause\",\n        \"test\": {\n          \"tag\": \"BoolExp\",\n          \"val\": true\n        },\n        \"then\": [\n          {\n            \"tag\": \"CondExp\",\n            \"condClauses\": [\n              {\n                \"tag\": \"CondClause\",\n                \"test\": {\n                  \"tag\": \"AppExp\",\n                  \"rator\": {\n                    \"tag\": \"PrimOp\",\n                    \"op\": \"=\"\n                  },\n                  \"rands\": [\n                    {\n                      \"tag\": \"NumExp\",\n                      \"val\": 3\n                    },\n                    {\n                      \"tag\": \"NumExp\",\n                      \"val\": 3\n                    }\n                  ]\n                },\n                \"then\": [\n                  {\n                    \"tag\": \"NumExp\",\n                    \"val\": 12\n                  }\n                ]\n              },\n              {\n                \"tag\": \"CondClause\",\n                \"test\": {\n                  \"tag\": \"BoolExp\",\n                  \"val\": true\n                },\n                \"then\": [\n                  {\n                    \"tag\": \"NumExp\",\n                    \"val\": 27\n                  }\n                ]\n              }\n            ]\n          }\n        ]\n      }\n    ]\n  }\n}\n```\n\n\n## Parsing a string into S-Exp\n\nWe note that the method `parseSexp` we used as a shortcut that translates a string into an S-Exp can be easily implemented. It combines both actions of a **scanner** (which transforms a string into a stream of tokens) and a **reader** (which transforms a stream of tokens into S-Exp).\n\nProvided here is a (Python) pseudocode of a possible implementation of such a method:\n\n```python\ndef parse_sexp(string):\n    \"\"\"\n    >>> parse_sexp(\"(+ 5 (+ 3 5))\")\n    [['+', '5', ['+', '3', '5']]]\n    \n    \"\"\"\n    sexp = [[]]\n    word = ''\n    in_str = False\n    for char in string:\n        if char is '(' and not in_str:\n            sexp.append([])\n        elif char is ')' and not in_str:\n            if word:\n                sexp[-1].append(word)\n                word = ''\n            temp = sexp.pop()\n            sexp[-1].append(temp)\n        elif char in (' ', '\\n', '\\t') and not in_str:\n            if word:\n                sexp[-1].append(word)\n                word = ''\n        elif char is '\\\"':\n            in_str = not in_str\n        else:\n            word += char\n    return sexp[0]\n```\n\nNotice the use of the methods `append (push)` and `pop` which emphasize the recursive nature of the task, which is logical since S-Expressions are formally defined using a BNF.\n\nYou can find more information about S-expressions [here](https://en.wikipedia.org/wiki/S-expression).\n"
    },
    {
        "name": "Lesson 5 - Operational Semantics",
        "content": "<h1><b>Operational Semantics</b></h1>\n\n<h2><b>Practical Session - Week #5</b></h2>\n\nThe operational semantics of a programming language is specified by a set of formal evaluation rules that operate on the AST of an expression. \nThe evaluation process can be specified as an algorithm ***eval(exp) : [AST -> Value]***.\n\nIn this session, we review:\n\n* **What is an Environment**\n\n* **Handling Primitives in the Operational Semantics**\n\n* **Renaming and Substitute**\n\n* **applicative-eval *vs* normal-eval**\n\n* **letrec**\n\n\n\n<h3><b>What is an Environment?</b></h3>\n\nAn environment represents a partial function (as opposed to a total function) from symbols (variable names) to values.\nIt supports the operation ***apply-env(env, var)*** which either returns the value of ***var*** in the environment ***env***, or else throws an error.\n\nWe define the environment data type inductively by the following definition:\n```typescript\ntype Env = EmptyEnv | NonEmptyEnv;\ntype EmptyEnv = {tag: \"EmptyEnv\"}\ntype NonEmptyEnv = {tag: \"Env\"; var: string; val: Value; nextEnv: Env;}\n```\n\nThe ***apply-env*** operation is defined recursively according to the structure of the data type:\n```typescript\nexport const applyEnv = (env: Env, v: string): Result<Value> =>\n    isEmptyEnv(env) ? makeFailure(\"var not found \" + v) :\n    env.var === v ? makeOk(env.val) :\n    applyEnv(env.nextEnv, v);\n```\n\nExample of an environment and a corresponding look-up operation - using the environment implementation\nused in class:\n\n```typescript\napplyEnv(makeEnv('x', 3,\n           makeEnv('y', 2,\n              makeEnv('x', 1, makeEmptyEnv())), 'x')\n=> { tag: 'Ok', value: 3 }\n```\n\nNote how the external binding for ***x*** to 3 hides the internal binding of ***x*** to 1.\n\n```typescript\napplyEnv(makeEnv('x', 3,\n           makeEnv('y', 2,\n             makeEnv('x', 1, makeEmptyEnv())), 'y')\n=> { tag: 'Ok', value: 2 }\n```\n\n```typescript\napplyEnv(makeEnv('x', 3,\n           makeEnv('y', 2,\n             makeEnv('x', 1, makeEmptyEnv())), 'z')\n=> { tag: 'Failure', message: 'var not found z' }\n```\n\n\n<h3><b>Handling Primitives in L1</b></h3>\n\nLet us recall the syntax of L1 using the BNF + Abstract Syntax specification we have developed in the previous lectures:\n\n```scheme\n<program> ::= (L1 <exp>+) // program(exps:List(exp))\n<exp> ::= <define-exp> | <cexp>\n<define-exp> ::= (define <var-decl> <cexp>) // def-exp(var:var-decl, val:cexp)\n<cexp> ::= <num-exp> // num-exp(val:number)\n       | <bool-exp>  // bool-exp(val:boolean)\n       | <prim-op>   // prim-op(op:string)\n       | <var-ref>   // var-ref(var:string)\n       | (<cexp> <cexp>*) // app-exp(rator:cexp, rands:List(cexp))\n<prim-op> ::= + | - | * | / | < | > | = | not\n<num-exp> ::= a number token\n<bool-exp> ::= #t | #f\n<var-ref> ::= an identifier token\n<var-decl> ::= an identifier token\n```\n\nThe values that can be returned in L1 are:\n\nValue = number \\| boolean \\| PrimOp\n\n **Note:**  In L1, the only side-effect that we can get is from a ***define*** expression.\n\n<h4><b> Representing Primitive Operators </b></h4>\n\nIn Scheme, when we compute this expression, we get:\n```scheme\n> +\n#<procedure:+>\n```\nThat is, the value of the + expression (which is an expression of type Symbol) is a procedure in Scheme. \n\nOn the other hand, in JavaScript, when we evaluate the expression \"+\" we get:\n```javascript\n+;\n ^\nSyntax Error: Unexpected token ; ...\n```\n\n(In Node - the reader keeps waiting for the continuation of the expression starting with + or -).\n\nThat is, in the syntax of JavaScript - primitive operators alone are not expressions - they are only defined as part of larger expressions that contain them.\n\nIn the code reviewed in class, we implemented primitive operators as syntactic expressions of type prim-op.\nWe represented primitive operators as a specific expression type in the AST <br/>***PrimOp(op: string)***. \nThe value of a prim-op expression is itself. \nWhen we apply a primitive operator to arguments, we explicitly dispatch to each known primitive operator in the language and apply the corresponding primitive operation in the meta-language.\nThis happens in the procedure <br/>***apply-primitive***.\n\nLet us implement a different strategy which is the same as in Scheme: primitives are variable references which refer to primitive procedures which \nare pre-defined in the global environment.\n\nThe steps of the change are:\n\n* Change the syntax to represent primitive operators as VarRef expressions \n* Change the type returned when we evaluate a primitive operator\n* Change the evaluation rules to support the evaluation of primitive operators as VarRef expressions that refer to primitive procedures\n\nThe result of all the changes discussed in this section appears in accompanying zip file.\n\n<h4><b> Change of AST for Primitives</b></h4>\n\n```scheme\n;; The main change is that we remove the expression type prim-op\n<cexp> ::= <num-exp> // num-exp(val:number)\n       | <bool-exp>  // bool-exp(val:boolean)\n       | <var-ref>   // var-ref(var:string)\n       | (<cexp> <cexp>*) // app-exp(rator:cexp, rands:List(cexp))\n```\nNow, when we parse an expression such as <code>(L1 (* 3 2))</code> we obtain an AST:\n\n```json\n{\n    \"tag\": \"Program\",\n    \"exps\": [\n        {\n            \"tag\": \"AppExp\",\n            \"rator\": {\n                \"tag\": \"VarRef\",\n                \"var\": \"*\"\n            },\n            \"rands\": [\n                {\n                    \"tag\": \"NumExp\",\n                    \"val\": 3\n                },\n                {\n                    \"tag\": \"NumExp\",\n                    \"val\": 2\n                }\n            ]\n        }\n    ]\n}\n```\ninstead of:\n\n```json\n{\n    \"tag\": \"Program\",\n    \"exps\": [\n        {\n            \"tag\": \"AppExp\",\n            \"rator\": {\n                \"tag\": \"PrimOp\",\n                \"op\": \"*\"\n            },\n            \"rands\": [\n                {\n                    \"tag\": \"NumExp\",\n                    \"val\": 3\n                },\n                {\n                    \"tag\": \"NumExp\",\n                    \"val\": 2\n                }\n            ]\n        }\n    ]\n}\n```\n<h4><b>Change the Structure of the Returned Values</b></h4>\n\nThe second change is now how to evaluate the sub-expression ```{ \"tag\": \"VarRef\", \"var\": \"*\" }```: in this case, we expect to obtain a value of a different type - which is a primitive procedure mapped to the variable <b>*</b> in the global environment.\n\nThis has an impact on the structure of the values the interpreter can return:\n\n\n* In the class implementation, for L1, Value = number \\| boolean \\| PrimOp\n* In the new implementation, we have: Value = number \\| boolean \\| <b>PrimProc</b>\n\n\nwhere ***PrimProc*** is the type of the values returned in the meta-language (TypeScript in our case) when we compute the expressions <b>+, *, -, /, not, <, >, =</b>.\n\nIn more details, we define:\n\n```typescript\nexport type Value = number | boolean | PrimProc;\ntype PrimitiveProcedure = (args: Value[]) => Value;\ntype PrimProc = {\n    tag: \"PrimProc\";\n    op: PrimitiveProcedure;\n};\n```\n\n\n<h4><b> Change the applyPrimitive procedure </b></h4>\n\nThe original version of <code>applyPrimitive</code> is:\n\n```typescript\nconst applyPrimitive = (proc: PrimOp, args: Value[]): Result<Value> =>\n    proc.op === \"+\" ? makeOk(reduce((x, y) => x + y, 0, args)) :\n    proc.op === \"-\" ? makeOk(reduce((x, y) => x - y, 0, args)) :\n    proc.op === \"*\" ? makeOk(reduce((x, y) => x * y, 1, args)) :\n    proc.op === \"/\" ? makeOk(reduce((x, y) => x / y, 1, args)) :\n    proc.op === \">\" ? makeOk(args[0] > args[1]) :\n    proc.op === \"<\" ? makeOk(args[0] < args[1]) :\n    proc.op === \"=\" ? makeOk(args[0] === args[1]) :\n    proc.op === \"not\" ? makeOk(!args[0]) :\n    makeFailure(\"Bad primitive op \" + proc.op);\n```\nIn the new version - we replace it with the following:\n\n```typescript\nconst applyPrimitive = (proc: PrimProc, args: Value[]): Result<Value> =>\n    makeOk(proc.op(args));\n```\n\nThis is a shorter version of the function - but one that exploits the fact that we have pre-defined the primitive functions\nand bound them to functions in the meta-language that all expect arguments in the same form (an array of Values).\n\n<h4><b> Initializing the Global Environment with Primitive Values</b></h4>\n\nThis last step is where we map variable references to actual TypeScript functions.\nWe initialize the global environment with the bindings of the primitives defined in L1 to the corresponding procedures in the meta-language.\n\n```typescript\nconst makeGlobalEnv = (): Env => \n  makeEnv('+', plus,\n    makeEnv('-', minus,\n      makeEmptyEnv()))\n\n// where:\nconst plus : (args: number[]) => number =\n    reduce((x, y) => x + y, 0, args)\nconst minus : (args: number[]) => number =\n    reduce((x, y) => x - y, 0, args)\n```\nAnd in the procedure ```evalL1program```, we initialize the global environment differently:\n\n```typescript\nconst evalL1program = (program: Program): Value =>\n    evalExps(program.exps, makeGlobalEnv());  // instead of makeEmptyEnv()\n```\n\n\nThis implementation explains properly what is meant by \"primitive functions\": they are the functions which are pre-defined in the global environment when the interpreter starts running - without the need for the programmer to define them.\n\n<h4><b> Adding a Primitive to the Interpreter</b></h4>\n\nWith this implementation, it is easy to add a primitive to the interpreter - we need only:\n* Add the proper binding in the initialization of the global environment\n\n\nFor example:\n\n```typescript\n// Primitive operators are encoded as varRef bound out of the box to\n// functions in the meta-language with an appropriate interface.\n// The PrimProc wrapper is used to tag such primitive operator values in\n// an unambiguous manner.\nconst makeGlobalEnv = (): Env =>\n    makeEnv('+', makePrimProc((args: number[]) => reduce((x, y) => x + y, 0, args)),\n    makeEnv('-', makePrimProc((args: number[]) => reduce((x, y) => x - y, 0, args)),\n    makeEnv('*', makePrimProc((args: number[]) => reduce((x, y) => x * y, 1, args)),\n    makeEnv('/', makePrimProc((args: number[]) => reduce((x, y) => x / y, 1, args)),\n    makeEnv('display', makePrimProc((args: Value[]) => console.log(args)),\n    makeEnv('newline', makePrimProc((args: Value[]) => console.log(\"\")),\n    makeEmptyEnv()))));\n```\n\nand we have two new primitives in our language (display and newline).\n\n\n<h3><b>Order of Evaluation of Parameters in a Procedure Application</b></h3>\n\nevalL1program(program) receives a program, which includes an ordered sequence of expressions. \nIt iterates over the expressions and depending on the type of each expression, it either evaluates a ***DefineExp*** and obtains a new environment, which is then used to evaluate the next steps of the program; or it evaluates the expression.\n\nIn expressions such as `(+ (+ 1 2) (+ 3 4) (+ 5 6))` the operational semantics does <b>not</b> specify the order of execution among the arguments - we could compute (+ 5  6) first and (+ 1 2) next, or in reverse, or even together (in parallel).\n\nThis is the case in the formal semantics of Scheme - the standard explicitly indicates that the order of evaluation of operands in an application is NOT specified.\n\nThis means that we can obtain different outputs if we insert side-effects as part of the operands depending on the implementation in Scheme:\n\n```scheme\n(define side-effect\n  (lambda (x) (display x) x))\n\n(+ (* (side-effect 2) (side-effect 3))\n   (* (side-effect 4) (side-effect 5)))\n\n=> can display \n2345 26\n\nor\n4235 26\n\n(or any other variant of the order of parameters)\n```\n\n\n<h3><b>L2 Evaluation</b></h3>\n\nNOTE: In the rest of the notes, we return to the syntactic treatment of primitives as discussed in the lectures\n(as opposed to the semantic treatment discussed above).\n\n\nThe syntax of  L2  extends that of  L1  with two new expression types:\n***IfExp*** and ***ProcExp***\n\n```scheme\n<program> ::= (L2 <exp>+) // program(exps:List(exp))\n<exp> ::= <define-exp> | <cexp>\n<define-exp> ::= (define <var-decl> <cexp>) // def-exp(var:var-decl, val:cexp)\n<cexp> ::= <num-exp> // num-exp(val:number)\n       | <bool-exp>  // bool-exp(val:boolean)\n       | <prim-op>   // prim-op(op:string)\n       | <var-ref>   // var-ref(var:string)\n       | (if <exp> <exp> <exp>) // if-exp(test,then,alt)                                    ##### L2\n       | (lambda (<var-decl>*) <cexp>+) // proc-exp(params:List(var-decl), body:List(cexp)) ##### L2\n       | (<cexp> <cexp>*) // app-exp(rator:cexp, rands:List(cexp))\n<prim-op> ::= + | - | * | / | < | > | = | not\n<num-exp> ::= a number token\n<bool-exp> ::= #t | #f\n<var-ref> ::= an identifier token\n<var-decl> ::= an identifier token\n````\n\nThe Value types includes closure values in addition to the previous types:\n\nValue = Number \\| Boolean \\| Prim-op \\| <b>Closure</b>\n\n\n* ***We define the closure data type as a record with two fields:***\n\n* ***Params: a list of VarDecl values***\n\n* ***Body: a list of cexp values***\n\n<b>\n`Closure ::= (Closure (<var-decl>*) <cexp>+) // closure(params:List(var-decl), body:List(cexp))`\n</b>\n\n<b>Note</b> that a proc-exp ```(lambda (x) (* x x))``` is an <b>expression</b> while a closure is a <b>value</b>.\nThey are of 2 different types - closures are the result of a computation.\n\nThe key change in L2 vs L1 is the support of closures when applying procedure values to arguments:\n\n```typescript\nconst L3applyProcedure = (proc: Value, args: Value[], env: Env): Result<Value> =>\n    isPrimOp(proc) ? applyPrimitive(proc, args) :\n    isClosure(proc) ? applyClosure(proc, args, env) :\n    makeFailure(\"Bad procedure \" + JSON.stringify(proc));\n\nconst applyClosure = (proc: Closure, args: Value[], env: Env): Result<Value> => {\n    let vars = map((v: VarDecl) => v.var, proc.params);\n    let body = renameExps(proc.body);\n    let litArgs = map(valueToLitExp, args);\n    return evalSequence(substitute(body, vars, litArgs), env);\n}\n```\nThe body is evaluated with ***evalExps*** - but we only return the last value that is computed:\nFor example:\n```scheme\n(lambda (x)\n    (+ 1 x)\n    (+ 2 x)) \n```\n\nFirst we evaluate`(+ 1 x)` only then we evaluate `(+ 2 x)`. The return value is the return value of the last expression. \n\nThe substitution procedure addresses 3 issues:\n* <b>we make sure the body is renamed so that we avoid capturing free variables</b>\n\n* <b>we map the evaluated arguments to expressions to ensure that the result of the substitution is a well-typed AST which can be evaluated (this is done with the procedure ***valueToLitExp***)</b>.\n\n* <b>we do not replace bound variables inside the body - only free variables</b>\n\n\n<h3><b>Renaming and Substitution</b></h3>\n\n<h4><b>Renaming</b></h4>\n\nBound variables in expressions can be consistently renamed by new variables (that do not occur in the expression) without changing the intended meaning of the expression.\nThat is, expressions that differ only by consistent renaming of bound variables are semantically equivalent.\n\nFor example, the following are equivalent pairs:\n\n```scheme\n(lambda (x) x) <==> (lambda (x1) x1)\n(lambda (x) (+ x y)) <==> (lambda (x1) (+ x1 y))  // y is not renamed because it occurs free\n```\n      \nWhy renaming?\n      \n```scheme\n(define z not)\n\n(((lambda (x)\n     (lambda (z)\n        (x z)))\n  (lambda (w)\n     (z w)))\n  ;; Note: z occurs free in the parent exp.\n #f)\n```\n\nFor renaming we use the ***renameExps*** procedure:\n```typescript\nconst makeVarGen = (): (v: string) => string => {\n    let count: number = 0;\n    return (v: string) => {\n        count++;\n        return `${v}__${count}`;\n    }\n}\n\n/*\nPurpose: Consistently rename bound variables in 'exps' to fresh names.\n         Start numbering at 1 for all new var names.\n*/\nconst renameExps = (exps: CExp[]): CExp[] => {\n    const varGen = makeVarGen();\n    const replace = (e: CExp): CExp =>\n        isIfExp(e) ? makeIfExp(replace(e.test), replace(e.then), replace(e.alt)) :\n        isAppExp(e) ? makeAppExp(replace(e.rator), map(replace, e.rands)) :\n        isProcExp(e) ? replaceProc(e) :\n        e;\n    // Rename the params and substitute old params with renamed ones.\n    // First recursively rename all ProcExps inside the body.\n    const replaceProc = (e: ProcExp): ProcExp => {\n        const oldArgs = map((arg: VarDecl): string => arg.var, e.args);\n        const newArgs = map(varGen, oldArgs);\n        const newBody = map(replace, e.body);\n        return makeProcExp(map(makeVarDecl, newArgs),\n                           substitute(newBody, oldArgs, map(makeVarRef, newArgs)));\n    }\n    return map(replace, exps);\n}\n```\n\nNotes on rename-exps:\n\n* The structure of renameExps is the same as that of rewrite-ASTs we saw in the previous lectures - a traversal of the AST top down with recursion on the components.\n\n* The only transformation renameExps does is on expressions of type ProcExp - all other expression types are copied as is.\n\n* It is a <b>pre-condition</b> of <code>substitute</code> that the expressions in which the substitution is performed are renamed. This pre-condition is enforced in the code of ***renameExps***, before we call substitute, we make sure the body is renamed .\n\n\n\n<b> Substitution </b>\n\nSubstitute is an operation which replaces free occurrences of variable references in an expression by other expressions.\n<b>Definition:</b> A substitution s is a mapping from a finite set of variables to a finite set of expressions.\n\nSubstitutions are denoted using set notation. For example:\n\n```\n6 o {x=5} = 6\n\n(+ x y) o {z = 5} = (+ x y)\n \n(+ x y) o {x=5, y=6, z=7} = (+ 5 6)\n\n(lambda (x) (+ x 6)) o {x=5} = \n    renaming: E turns into (lambda (x1) (+ x1 6)\n    substitute: E turns into (lambda (x1) (+ x1 6))\n\n( + (x z) ((lambda (x) x) y))  o {x = (lambda (x) x) , y = 7 , z =8}\n    renaming: E turns into ( + (x z) ((lambda (x1) x1) y)) \n    renaming: s turns into {x = (lambda (x2) x2) , y = 7, z = 8}\n    substitute: E turns into  ( + ((lambda (x2) x2) 8) ((lambda (x1) x1) 7))\n```\n\nComposition (combination) of Substitutions s  and  s\u2032 , denoted  s\u2218s\u2032 , is a substitution  s\u2033  that extends  s  with a binding <x; s' (x)> for every variable  x  for which  s(x) is not defined.\n\nFor example: \n```\n#1: {} o {x = 3} = {x = 3}\n\n#2: {x = 3} o {y = #t} = {x = 3, y = #t}\n\n#3: {x = y} o {y = 3} = {x = 3, y = 3}            // Note that the binding of x changed to 3\n\n#4: {x = y} o {y = x} = {x = x, y = x} = {y = x}  // What happens when we apply this substitution?\n```\nLet us explain #3 and #4:\n\nApplying `{x = y} o {y = 3}] (s o s')` to any expression E, we want to obtain the same result as performing first s' then s - that is:\n\n`\nFor any E, E o [{x = y} o {y = 3}] = [E o {x = y}] o {y = 3}\n`\n\nLet us take an example for E that contains x and y:\n\n`\nE = (x y)\nE o [{x = y} o {y = 3}] \n= [E o {x = y}] o {y = 3}\n= (y y) o {y = 3}\n= (3 3)\n`\nAfter applying {x = y} there are no more instances of x, only instances of y in the result.\nTherefore, when we replace <b>simultaneously</b> x and y in the composed substitution, we must make sure x is replaced to 3 and not to y.\n\nLet us look at #4: we apply the same logic as in #3, and obtain that:\n\n`\n[{x = y} o {y = x}] = [{x = x, y = x}]\n`\n\nThe substitution of x into x is not introducing any modification, therefore, we can drop it - and we obtain:\n\n`\n[{x = y} o {y = x}] = [{x = x, y = x}] = {y = x}\n`\n\nSubstitution involves renaming as a first step:\n\n```\n((+ x ((lambda (x) (* x 2)) 3))) o {x = 5} =\n    Renaming: ((+ x ((lambda (x1) (* x1 2)) 3)))\n    Substitute: ((+ 5 ((lambda (x1) (* x1 2)) 3)))\n```\n\n<h3><b>Question: Why do we need renaming?</b></h3> \n\nLet us look at this program:\n\n***(lambda (x) (lambda (y) (y x)))***\n\nrename ***x*** -> ***a***, ***y*** -> ***b***  - all ok:\n\n***(lambda (a) (lambda (b) (b a)))***\n\nFrom this, you might conclude that any substitution is allowed - i.e. any variable in any lambda term can be replaced by any other. This is not so. Consider the inner lambda in the first expression above:\n\n***(lambda (y) (y x))***\n\nIn this expression, ***x*** is free - it is not bound by a lambda abstraction. If we were to replace ***y*** with ***x***, the expression would become:\n\n***(lambda (x) (x x))***\n\nBut we already specified that when we apply a substitution, we do not replace bound variables - so that:\n\n***(lambda (y) (y x))*** o {y = x}\n\nis not causing any harm - we return the same value unchanged, because y is bound.\n\nBut now consider what happens if we introduce a value into the expression that contains a binding with a name to a variable that occurred free in the original expression.\nThe replacement will lead to a capture of the free variable by the new binding. \n\n```scheme\n(define z not)\n\n(((lambda (x)\n     (lambda (z)\n        (x z)))\n  (lambda (w)\n     (z w)))\n  ;; Note: z occurs free in the parent exp.\n #f)\n```\nWork out the capture - step by step...\n\nHow it works with renaming:\n\n```scheme\n;; rename z in (lambda (z) (x z)) ==> (lambda (z1) (x z1))\n;; rename w in (lambda(w)(z w)) ==> (lambda(w1)(z w1))\n;; substitute (lambda(z1)(x z1)) \u2218 {x = (lambda(w1)(z w1))} ==> \n(lambda (z1)\n   ((lambda (w1)\n       (z w1)) ;z remains free!\n    z1))\n\n;; substitute ((lambda (w1) (z w1)) z1)\u2218 {z1 = #f}==>\n((lambda(w1)\n    (z w1))\n #f)\n\n;;substitute (z w1) \u2218 {w1 = #f}==>\n(z #f)\n\n;;substitute (z #f) \u2218 {z = not}==>\n(not #f) \n#t\n```\n\n<h3><b>Applicative Eval</b></h3>\n\nLook at the next code:\n```scheme\n((lambda (x z) \n    (* (+ x z) z))\n 1\n (+ 1 2))\n```\n<b>Q: </b> Evaluate the following expression according to the applicative-eval algorithm\n\n<b> A:</b>\n```\napplicative-eval     [((lambda (x z) (* (+ x z) z)) 1 (+ 1 2))]\n    applicative-eval [(lambda (x z) (* (+ x z) z))] ==> <Closure (x z) (* (+ x z) z)>\n    applicative-eval [1] ==> 1\n    applicative-eval [(+ 1 2)]\n        applicative-eval [+] ==> #<primitive-procedure +>\n        applicative-eval [1] ==> 1\n        applicative-eval [2] ==> 2\n   3\nreduce:\n    applicative-eval [(* (+ 1 3) 3)]\n        applicative-eval [*] ==> #<primitive-procedure *>\n        applicative-eval [(+ 1 3)]\n            applicative-eval [+] ==> #<primitive-procedure +>\n            applicative-eval [1] ==> 1\n            applicative-eval [3] ==> 3\n        ==> 4\n        applicative-eval [3]==> 3\n    12\n```\n\n\n<h3><b>Normal Eval</b></h3>\n\n<b> Q:</b>  Evaluate the following expression according to the normal evaluation algorithm:\n```scheme\n(((lambda (x)\n     (lambda (y) \n        (* x y))) \n  (+ 1 2)) \n  2)  \n```\n\n<b>A:</b>\n\n```\nnormal-eval[ (( (lambda (x)(lambda (y)(* x y)))(+ 1 2))2) ]\n  normal-eval [( (lambda (x)(lambda (y)(* x y)))(+ 1 2)) ]\n    normal-eval[(lambda (x)(lambda (y)(* x y)))] ==><closure (x) (lambda(y) (* x y))>\n    substitute:\n    (lambda(y) (* x y) ) \u1d52 {x = (+ 1 2) } ==> (lambda(y) (* (+ 1 2) y) )\n    reduce:\n    normal-eval[lambda(y) (* (+ 1 2) y) ] ==><closure (y) (* (+ 1 2) y)>\n    substitute:\n    (* (+ 1 2) y) \u1d52 { y = 2} ==> (* (+ 1 2) 2)\n    Reduce:\n    Normal-eval[ * (+ 1 2) 2 ] ==>\n      Normal-eval[ * ] ==> <primitive-procedure: *>\n      Normal-eval[ ( + 1 2) ] ==>\n        Normal-eval[+] ==> <primitive-procedure: +>\n        Normal-eval[1] ==> 1\n        Normal-eval[2] ==> 2\n      ==> 3\n      Normal-eval[2] ==> 2\n   ==> 6\n```\n\n<h3><b>applicative-eval VS normal-eval</b></h3>\n\n<b>Q:</b>Does the evaluation Strategy matter? \n\nLet us look at the next program:\n\n```scheme\n(define test\n  (lambda (x y)\n    (if (= x 0)\n        0\n        y)))\n\n(define zero-div\n  (lambda (n)\n    (/ n 0))) ; division by zero!\n\n(test 0 (zero-div 5))\n```\n\n<b> Normal Eval </b>\n\n```\nnormal-eval[(test 0 (zero-div 5))]\n    normal-eval[test] ==> <closure (lambda (x y) (if (= x 0) 0 y))>\n\n(if (= x 0) 0 y))\u1d52{x = 0} ==> (if (= 0 0) 0 y))\n\n(if (= 0 0) 0 y))\u1d52{y = (zero-div 5)} ==> (if (= 0 0) 0 (zero-div 5) ))\n\nreduce:\n\nnormal-eval[(if (= 0 0) 0 (zero-div 5)))]\n    normal-eval[(= 0 0)]\n        normal-eval[ = ] ==>#<primitive-procedure =>\n    normal-eval[ 0 ] ==>0\n    normal-eval[ 0 ] ==>0\n    ==> #t\n    normal-eval[0] ==> 0\n==>0\n```\n\nNotice that we didn't evaluate ***(div-zero 5)***!\n\n<b> Applicative Eval </b>\n\n```\napplicative-eval[(test 0 (zero-div 5))]\n    applicative-eval[test] ==> <closure (lambda (x y) (if (= x 0) 0 y))>\n    applicative-eval[0] ==> 0\n    applicative-eval[(zero-div 5)]\n        applicative-eval[zero-div]==><closure (lambda (n) (/ n 0))>\n        applicative-eval[5]==> 5\n```\n\nWe get a <b>\"division by zero\"</b> error !!!\n\n\nAnother example:\n\n```scheme\n(define loop (lambda (x) (loop x)))\n\n(define g (lambda (x y) y))\n\n(g (loop 0) 7)\n```\n\nnormal-eval will return 7 while applicative-eval will get into infinite loop.\nwhy is that?\n\n\nWe saw two examples where different manner of evaluation get different result.\n\n<b>Notice:</b> If both evaluations don't get into an infinte loop and/or an error - they both return the same value!\n\n<h3><b> Distinguish between different evaluation strategies</b></h3>\n\n<b>Q: </b> How can we distinguish what evaluation strategy the interpreter is using?\n\n<b>A:</b>\nAs we saw in the previous questions -\n \nif we understand the differences between the evaluations methods we can write a program that each method will act different on.\n\nfor example:\n```scheme\n(define applic\n  (lambda ()\n    (display 'applic)\n    0))\n\n(define test (lambda (x) 1))\n\n(test (applic))\n```\n\nNormal eval will not have any side-effects while applicative eval will display \"applic\" to the screen.\nThey both will return the value 1.\n\n<!---\n\n<h3><b> letrec </b></h3>\n\nLet us recall the exp procedure:\n```scheme\n; Signature: exp(b e)\n; Purpose: to compute the function b^e\n; Type: [Number * Number -> Number]\n; Pre-conditions: b >= 0, e is natural\n; Tests:\n; (exp 2 3) => 8\n; (exp 2 4) => 16\n; (exp 3 4) => 81\n\n(define exp\n  (lambda (b e)\n    (exp-iter b e 1)))\n\n(define exp-iter\n  (lambda (b e acc)\n    (cond ((= e 0) acc)\n           (else (exp-iter b (- e 1) (* b acc))))))\n```\n\nIn this program both \"exp\" and \"exp-iter\" are public functions.\nbut the user will only use \"exp\" so we want \"exp-iter\" to be non-public procedure.\n\nhow can we do that?\n\n<b>First attempt:</b>\nwe will use let\n\n```scheme\n(define exp\n  (lambda (b e)\n    (let ((exp-iter (lambda (b e acc)\n                      (cond ((= e 0) acc)\n                      (else (exp-iter b (- e 1) (* b acc)))))))\n    (exp-iter b e 1))))\n```\n\n<b>Q:</b> What is the problem with that program?\n\n<b>A:</b> We use ***exp-iter*** in its definition (why is that a problem?)\n\n<b>Second attempt:</b>\n\n```scheme\n(define exp\n  (lambda (b e)\n    (letrec ((exp-iter (lambda (b e acc)\n                         (cond ((= e 0) acc)\n                         (else (exp-iter b (- e 1) (* b acc)))))))\n    (exp-iter b e 1))))\n```\n\nHere we use letrec instead let so a defintion of a procedure can be recusive.\n\nCan we do it better? Yes! By noticing that ***b*** stays constant throughout ***exp-iter***, we can just use the existing ***b*** instead of passing it around as an argument.\n\n<b> Third attempt:</b>\n\n```scheme\n(define exp\n  (lambda (b e)\n    (letrec ((exp-iter (lambda (e acc)\n                         (cond ((= e 0) acc)\n                         (else (exp-iter (- e 1) (* b acc)))))))\n    (exp-iter e 1))))\n```\n\n-->\n"
    },
    {
        "name": "Lesson 6 - Environment Model",
        "content": "<h1><b>Environment Model</b></h1>\n\n<h2><b>Practical Session - Week #6</b></h2>\n\nIn this session, we will:\n* ***Introduce the environment model***\n\n* ***Understand how to evaluate Scheme expressions in this model***\n\n* ***Learn how to draw environment diagrams and procedure calls***\n\n* ***Distinguish different scoping policies***\n\n<h3><b>Introduction</b></h3>\n<b>Q:</b> we already learned about the \"Substitution\" evaluation model, why do we need another one?\n\nThe environment model is an optimization of the substitution applicative model of the operational semantics. \nIt changes the way we map variables to their values.\n* ***Instead of eagerly substituting variables by their values when we apply a closure, we leave the body of the closure untouched, and maintain an environment data structure on the side.***\n\n* ***The current environment is passed when traversing expressions to evaluate them.***\n\n* ***When we evaluate a procedure expression, we construct a closure value which saves the current env (at time of closure creation).***\n\n* ***When we evaluate an application expression, we construct a new environment - which is made up of the closure environment extended by the mapping of params to args.***\n\n* ***Environments are linked lists of frames.***\n\n* ***An extended environment is constructed by adding a new frame to an existing environment.***\n\n\n\n<h3><b>Q: Why do we need to nest environments?</b></h3>\n\nWe do not have a single frame that contains all the variables defined in the body of a closure - instead we may need to lookup\nvariables in other frames.  This is because we construct a new frame only when we enter a new scope.\nA new scope is entered when the interpreter enters a let-exp or when it applies a closure.\nAt this point, the expression we execute in the current scope may refer to variables that come from the enclosing scope - according\nto lexical scoping rules.\n\nConsider this program:\n```scheme\n(let ((x 1))                ;; Enter scope E1\n  (let ((y (+ x 1)))        ;; Enter scope E2\n    (+ (* y y) x)))\n```\n\nWhen we compute the body of the inner-let <code>(+ (* y y) x)</code>, variable **y** is defined in the first frame accessible (head of E2),\nand variable **x** is defined in the second frame accessible (head of E1). E1 has E2 as a tail.\n\n\nConsider this program:\n```scheme\n(let ((x 1))                ;; Enter scope E1\n  (let ((x (+ x 1)))        ;; Enter scope E2\n    (+ x x)))    \n```\nwhen we compute the body of the inner-let the  variable **x** that was defined in E1 is hidden by the variable x that was defined in E2\n\n\n<h3><b>Q: Why do we use the closure environment and not the current environment when applying a closure to obtain lexical scoping? </b></h3>\n\nAt every step of the computation of an expression, the evaluation function has access to a parameter env which represents the <b>current environment</b>.\n\nWhen we apply a closure to arguments, we ignore the current environment, and instead evaluate the body of the closure in an environment which extends the \nenvironment stored in the closure with a frame that maps the parameters of the closure to the arguments on which it is applied.\n\nConsider this snippet:\n```scheme\n(define make-adder\n  (lambda (c)\n    (lambda (x) (+ x c))))\n\n(let ((a3 (make-adder 3)))  ;; E1\n  (let ((c 1))              ;; E2\n    (a3 2)))\n```\n\nWe observe in this program a risk that the variable `c` which appears free in the body of the closure returned when computing <code>(lambda (x) (+ x c))</code>\ncould be captured in the `let` of E2.\n\n<h4><b>How does this program work in the substitution model</b></h4>\n\n```\napplicative-eval[ (let ((a3 (make-adder 3)))\n                     (let ((c 1))\n                        (a3 2))] ==>\n\napplicative-eval[ ((lambda (a3) (let ((c 1)) (a3 2))) (make-adder 3))] ==>\n\n   applicative-eval[ (lambda (a3) (let ((c 1)) (a3 2))) ] ==>\n      closure <a3> (let ((c 1)) (a3 2))) ==>\n\n   applicative-eval[ (make-adder 3) ] ==>\n      applicative-eval[ make-adder ] ==> <closure <c> (lambda (x) (+ x c))>\n      applicative-eval[3] ==> 3\n   ==>\n   applicative-eval[(lambda (x) (+ x 3))] ==> <closure (x) (+ x 3)>\n\napplicative-eval[(let ((c 1)) (<closure (x) (+ x 3)> 2))] ==>\napplicative-eval[((lambda (c) (<closure (x) (+ x 3)> 2)) 1)] ==>\n   \n   applicative-eval[(lambda (c) (<closure (x) (+ x 3)> 2)] \n      ==> <closure (c) (<closure (x) (+ x 3)> 2)>\n   applicative-eval[1]\n      ==> 1\n   ...\n   applicative-eval[ (+ 2 3) ] ==>\n      applicative-eval[+] ==> <prime-op +>\n      applicative-eval[2] ==> 2\n      applicative-eval[3] ==> 3\n==> 5\n```\n\n<h4><b>How does it work in the environment model</b></h4>\n\n```scheme\n(let ((a3 (make-adder 3))) ;;E1\n  (let ((c 1))             ;;E2\n    (a3 2)))               ;;E3\n```\n\nwhen evaluating the body of the inner **let** <code>(a3 2)</code>:\n\nIf we use the current environment, we will use E2 to evaluate **c** in <code>(lambda (x) (+ x c))</code> and get <code>(+ 2 1)</code>\n\nIf we use the closure's environment, we will use E1 to evaluate **c** in <code>(lambda (x) (+ x c))</code> and get <code>(+ 2 3)</code>\n\n\n<h3><b>Environment Diagrams</b></h3>\n\nWe exercise the drawing of environment diagrams in the box-env model presented in class.\n\n<h4><b>Definitions</b></h4>\n\n* <b>Frame:</b> mapping variables to values.  Displayed as a rectangle with bindings x:val.\n\n* <b>Environment:</b> finite linked list of frames, where the last frame is the frame of the global \nenvironment (GE).\n\n* <b>Enclosing environment of E:</b> E excluding its first frame.\n\n* <b>Variable x's value in E:</b> the value of x in the first frame it is defined in.\n\nWhen a define expression is evaluated, a new binding is added to the GE single frame.\n![image:1_1.PNG](resources/ps6/1_1.png)\n\n* <b>Closure:</b> a complex data structure, composed of parameters, body, and env at the time the lambda expression was evaluated.\nDisplayed as a double circle, with body and params written below, and second circle pointing to the env.\n\n![image:1_2.PNG](resources/ps6/1_2.png)\n\n* <b>Procedure call:</b> when a closure f with parameters <code>x1...xn</code> is called with values <code>v1...vn</code>:\n\n   * The evaluation algorithm extends the closure's env with a new frame including the mapping from \n   <code>x1...xn</code> to <code>v1...vn</code>. \n   \n   * In the diagram, we assign a number to the environments to reflect the order in which they are created during the evaluation of the program. (Ei+1)\n   \n   * This new frame extends the env in the closure f (according to lexical scoping rule)\n   \n   * The new environment has a control link which indicates to which environment control returns when the evaluation of the body will complete.  This is marked with a dotted line.\n\n\n<h4><b>Env Diagram Example 1: Recursion</b></h4>\n\n![image:2_1.PNG](resources/ps6/2_1.png)\n\nNotice how the closure is pointing to the GE, and so each call to this closure (including recursive ones) will extend the GE. The depth of the recursion is represented by the control links.\nSuccessive recursive calls return in sequential order (Ei+1 control link points to Ei).\n\n<h4><b>Env Diagram Example 2: Definition and application</b></h4>\n\nConsider another example:\n\n![image:3_1.PNG](resources/ps6/3_1.png)\n\n![image:3_2.PNG](resources/ps6/3_2.png)\n\n<h4><b>Env Diagram Example 3: Definition and Let</b></h4>\n\nWhen we encounter a \"let\" expression, we can convert it to a lambda expression which we already know how to handle.\n\n![image:4_1.PNG](resources/ps6/4_1.png)\n\n![image:4_2.PNG](resources/ps6/4_2.png)\n\n<b>Q: </b>which environments and which procedures will remain in the end of the evaluation?\n\nThe closures f and p will remain.\nE3 will finish its evaluation and return to E2, which will finish and return to E1, which will finish and return to the GE.\nE1, E2, E3 will disappear since no accessible data structure refers to them anymore.\n\n<h4><b>Env Diagram Example 4: Inferring code from a diagram</b></h4>\nWhat program will generate the following environment diagram?\n\n![image:PS6_code_restoring.JPG](resources/ps6/PS6_code_restoring.jpg)\n\nWe can notice that the structure is serial, which implies nested applications of procedures.\n\nEach environment extends the previous one.\n\nThe following code will produce the environment diagram from above:\n```scheme\n(define x 5)\n\n(let ((a 2))\n  (let ((b 3))\n     (let ((c 4))\n        (+ x a b c))))\n```\n\n\n<h3><b>Pair Data Structure using Closures</b></h3>\n\n<h4><b>Env Diagram Example 4: lazy procedural pair implementation</b></h4>\n\n<b>Part A:</b>\n\n![image:5_1.PNG](resources/ps6/5_1.png)\n\n![image:5_2.PNG](resources/ps6/5_2.png)\n\nNotice p1 is a closure expecting a selector procedure. \nWhen we call p1, the env we extend will be E1, which is why we see x, y.\n\n<b>Part B:</b>\nWe will display a call to p1 with a selector:\n\n\n![image:6_1.PNG](resources/ps6/6_1.png)\n\nWatch the evaluation process:\n\n* There is a new closure created, which is the value of \"sel\" in the new env \"E2\".\n\n* The enclosing env of E2 is E1, which is why it was created by calling B2 - the only closure whose env is E1.\n\n* Parameter names in the new env, E3, present the parameter names in the code we build.\nfurthermore, the fact that E3 points to the GE shows us this env was created in the GE (not in a lambda or Let expression).\n\nWhat line of code needs to be added to produce this diagram?\n\nAccordingly, the env diagram for this evaluation is:\n\n```scheme\n(p1 (lambda (a b) a))\n```\n\n<b>Q: </b>which env and closures will remain at the end of the evaluation?\n<h3>set!</h3>\n\nset! is a way to change the value of a variable.\nfor example : \n\n```scheme\n>(define x 5)\n>x\n5\n>(set! x 80)\n>x\n80\n```\n\n<h2><b>Box</b></h2>\n\nBoxing in scheme is required to wrap a variable in a box, so we can access it through the box, but also change the value inside that box.\nA natural way to look at boxes is like pointers, which we can access data through but the data inside can be changed.\n\nIn the <b>box environment model</b>, we use boxing to enable mutation.  We saw in the lecture why we needed mutation to properly model recursion (letrec) and \nmodel the global environment with forward usage of global variables and global mutual recursive procedures.\n\nIn the box environment model variables are bound to boxes that contain a value, instead of mapping variables directly to values.\nIn addition, the global environment is modeled in a special way that allows addition of a binding (with a method add-binding!).\n\nMotivation: we want to support mutation in the language we implement.\nNote that at this point, all the variables are immutable - we can create a new variable and bind it to a value, but we cannot change its value.\nIn some cases, we want to be able to change the value of an existing variable.\n\nExample: a counter.\n\n1) How do we do this in Scheme?\n\nWe use the box data type which has the following interface:\n```scheme\n(box v)\n(box? x)\n(unbox b)\n(set-box! b v)\n```\n\nBox works like a pointer to an existing variable.\n\nExample application - let us create a counter object.\n\n```scheme\n(define make-counter\n  (lambda ()\n    (let ((count (box 0)))\n      (lambda (msg)\n        (cond ((eq? msg 'get) (unbox count))\n              ((eq? msg 'inc!) (set-box! count (+ 1 (unbox count))))\n              ((eq? msg 'reset!) (set-box! count 0))\n              (else (error \"unknown message to counter\")))))))\n```\n\nThis counter works with the same pattern as the make-pair example we saw in class: it is a closure factory with a message dispatch body.\nThe functional interface of the counter is:\n\n```scheme\n;; Type: [Counter -> Number]\n(define counter-get\n  (lambda (counter) (counter 'get)))\n\n;; Type: [Counter -> Void]\n(define counter-inc!\n  (lambda (counter) (counter 'inc!)))\n\n;; Type: [Counter -> Void]\n(define counter-reset!\n  (lambda (counter) (counter 'reset!)))\n```\n\nHow to use a counter in code:\n\n```scheme\n;; Count how many odd numbers there are in a given tree.\n(define count-odds\n  (lambda (tree)\n    (let ((counter (make-counter)))\n      (letrec ((loop (lambda (tree)\n                       (cond ((empty? tree) (void))\n                             ((pair? tree) (loop (car tree)) (loop (cdr tree)))\n                             ((and (number? tree) (odd? tree)) (counter-inc! counter))))))\n        (loop tree)\n        (counter-get counter)))))\n```\n\n```scheme\n;; Variant of the counter object: functional selector instead of message dispatch (lazy selector)\n\n;; [Empty -> Counter]\n;; Counter is implemented as: [(Box(Number) -> Any) -> Any]\n(define (make-counter-sel)\n  (let ((count (box 0)))\n    (lambda (sel)\n      (sel count))))\n\n;; Implement counter interface:\n\n(define counter-sel-get\n  (lambda (counter-sel) \n    (counter-sel (lambda (b) (unbox b)))))\n\n(define counter-sel-inc!\n  (lambda (counter-sel) \n    (counter-sel (lambda (b) (set-box! b (+ 1 (unbox b)))))))\n\n(define counter-sel-reset!\n  (lambda (counter-sel) \n    (counter-sel (lambda (b) (set-box! b 0)))))\n```\n\n<h2><b>Adding set! to our language</b></h2>\n\nThere are 3 steps we should take to add set! to our language: \n* Add set! in the syntax: Should we consider set! a special form? Explain.\n* Add set! to the parser\n* Add set! to the env-eval algorithm\n\n<b>Syntax definition:</b>\n\n```\n<cexp> ::= ... | ( set! <var> <cexp>)            // SetExp(var: varRef, val: CExp)\n```\n\n<b> Adding type definitions for ***set!***: </b>\n\n```typescript\nexport interface SetExp {tag: \"SetExp\", var: VarRef; val: CExp; }\n\nexport const makeSetExp = (v: VarRef, val: CExp): SetExp =>\n    ({tag: \"SetExp\", var: v, val: val});\n\nexport const isSetExp = (x: any): x is SetExp => x.tag === \"SetExp\";\n```\n\n<b> Update the Compound disjoint union type: </b>\n\n```typescript\nexport type CompoundExp = AppExp | IfExp | ProcExp | LetExp | LitExp | LetrecExp | SetExp;\n\nexport const isCompoundExp = (x: any): x is CompoundExp =>\n    isAppExp(x) || isIfExp(x) || isProcExp(x) || isLitExp(x) || isLetExp(x) ||\n    isLetrecExp(x) || isSetExp(x);\n```\n\n<b> Modify the function ***parseL4SpecialForm***</b>\n\n```typescript\nexport const parseL4SpecialForm = (op: Sexp, params: Sexp[]): Result<CExp> =>\n    isEmpty(params) ? makeFailure(\"Empty args for special form\") :\n    op === \"if\" ? parseIfExp(params) :\n    op === \"lambda\" ? parseProcExp(first(params), rest(params)) :\n    op === \"let\" ? parseLetExp(first(params), rest(params)) :\n    op === \"quote\" ? parseLitExp(first(params)) :\n    op === \"letrec\" ? parseLetrecExp(first(params), rest(params)) :\n    op === \"set!\" ? parseSetExp(params) :\n    makeFailure(\"Never\");\n```\n\n<b> Add the parsing functions for ***SetExp***</b>\n\n```typescript\nconst parseSetExp = (params: Sexp[]): Result<SetExp> =>\n    isEmpty(params) ? makeFailure(\"set! missing 2 arguments\") :\n    isEmpty(rest(params)) ? makeFailure(\"set! missing 1 argument\") :\n    ! isEmpty(rest(rest(params))) ? makeFailure(\"set! has too many arguments\") :\n    parseGoodSetExp(first(params), second(params));\n\nconst parseGoodSetExp = (variable: Sexp, val: Sexp): Result<SetExp> =>\n    ! isIdentifier(variable) ? makeFailure(\"First arg of set! must be an identifier\") :\n    bind(parseL4CExp(val), (val: CExp) => makeOk(makeSetExp(makeVarRef(variable), val)));\n```\n\n<b>***env-eval***</b>\n\n```typescript\nconst evalSet = (exp: SetExp, env: Env): Result<void> =>\n    bind(applicativeEval(exp.val, env), (val: Value) => \n        bind(applyEnvBdg(env, exp.var.var), (bdg: FBinding) =>\n          makeOk(setFBinding(bdg, val))\n        )\n    )\n```\n"
    },
    {
        "name": "Lesson 7 - Type Inference.md",
        "content": "\ufeff# Type inference using type constraints\n\n## Definition (seen in class):\n\nA **Type-substitution** is a mapping, s, from a finite set of type-variables to a finite set of type-expressions, such that for every type-variable T, s(T) does not include T.\nA type-binding is a pair  `<T,s(T)>`  such that  `T = s(T)`.\nType-Substitutions are written using set notation, for example :\n\n* **{T1 = Number, T2 = [Number -> T3]}**.\n* **{T1 = Number, T2 = [[Number -> T3]->T2]}, is this legal?**\n* **{T1 = Number, T1 = Boolean}, and this one?**\n\n\n## Question 1 \n### Typing statement\n\nA typing statement is a true/false formula that states a judgment about the type of a language expression, given a type environment.\n\nIt has the notation:  `Tenv \u22a2 e:T`, which reads: under the type-environment Tenv, the expression e has type T.\n\nE.g.,  `{x:Number} \u22a2 (+ 3 x):Number`  states that under the assumption that the type of x is Number, the type of (+ 3 x) is Number. For the typing statement below, note whether they are  **true or false:**\n\n* **{f:[Number->T1]} \u22a2 (f 7): T1**\t\n* **{y:Number, f:[T1->T1]} \u22a2 (f x):T1**\t\n* **{y:Number, f:[T1->T1]} \u22a2 (f y):T1**\t\n* **{x:Number} \u22a2 x: Boolean**\t\n* **{x:Boolean, y:Number} \u22a2 x: Boolean**\n* **{f:[T1->T2], g:[T2->T3], x:T1} \u22a2 (g (f x)):T3**\n\n## Question 2 \n\nA typing-statement is based on assumptions in a given type-environment.\nThe less assumptions are involved, the stronger is the statement.\nIn order to end up with the strongest statement, we follow a simple heuristic rule: always pick a minimal type environment (or: always infer the strongest statement possible). For each row of statements below, **which statement is stronger?** left or right ?\n\nNote : assumptions in Tenv are an added part to the axioms we have.\n\n|Term 1                         | Term 2 \n|-------------------------------|-----------------------------|\n|{foo: [T1->T2]} \u22a2 5: Number|{} \u22a2 5: Number  \n|{x: Number} \u22a2 (+ x 3): Number  |{y: Number,x: Number} \u22a2 (+ x 3): Number\n|{} \u22a2 (lambda (x)(+ x 3)):[Number -> Number]| {y: Number} \u22a2 (lambda (x)(+ x y)):[Number -> Number] <br> (Can we compare these two?)\n|{} \u22a2 (lambda (x)(+ x 3)):[Number -> Number]| {y:Number} \u22a2 (lambda (z)(+ z 3)):[Number -> Number]\n|{f:[Number -> Number]} \u22a2 ((lambda (f x) (f x))(lambda (x) (* x x)) 10): Number | {} \u22a2 ((lambda (f x) (f x)) (lambda (x) (* x x)) 10): Number|\n\nNote: A typing statement has to be true in order to determine its strength.\n\n## Definitions (seen in class):\n\nAn application of a type-substitution s to a type-expression TE, denoted by TE \u25cb s, is a consistent replacement of type-variables T in TE by their mapped type-expressions s(T).\nFor example:\n\n* **[[T1->T2]->T2] \u25cb {T1=Boolean, T2=[T3->T3]} = [[Boolean->[T3->T3]] -> [T3->T3]]**\n* **[[T1->T2]->T2] \u25cb {T1=Boolean, T2=[T3->T3],T3=Number} = [[Boolean->[T3->T3]] -> [T3->T3]]**\n* **[[T1->T2]->[T2->T3]] \u25cb {T1=Boolean, T2=[T3->T3],T3=Number} = [[Boolean->[T3->T3]] -> [[T3->T3]->Number]]**\n\n## Question 3\n\nA unifier of type expressions **TE1**, **TE2** is a type substitution s such that **TE1 \u25cb s = TE2 \u25cb s** (the type expressions should not include common type variables).\nThe most general unifier (**MGU**), is a unifier such that any other unifier is an instance of it.\n\nRecall the lecture's definition of \"instance of type expression\" :  **T'** is an instance of type expression **T**, if there is a type substitution **s** such that  `T o s = T'`.\n\nIn case of an instance of the MGU type substitution, it is any type substitution s such that for each type expression e in s, e is an instance of a type expression in our MGU.\nAll other unifiers are obtained from it by application of additional substitutions. \n\n**Find the MGU**  for the following pairs of type-environments:\n\n|Type expressions\t            | MGU\n|-------------------------------|-----------------------------|\n|{x: T1}, {x: Number}\t            |{T1=Number}  (a non-MGU unifier: {T1=Number, T2=B})\n|{x: T1}, {x: T2}\t            |{T1=T2}  (a non-MGU unifier: {T1=Number, T2=Number})\n|{x: [T1*[T1->T2]->T2]},  {x: [Number * [T3->T4]->T4]}\t    |{T1=Number, T3=Number, T4=T2}\n|{x: [T1*[T1->T2]->Number]},   {x: [[T3->T4] * [T5->Number]->Number]}  |{T1=[T3->T4], T5=[T3->T4], T2=Number}\n|{x: [T1*[T1->T2]->Number]},   {x: [Number * [Symbol->T3]->Number]}    |No unifier\n\n## Type inference using type constraints\n\n-   Rename bound variables.\n-   Assign type variables to all sub-expressions.\n-   Construct type equations.\n-   Solve the equations.\n\n### Typing rules\n\n-   For primitive atomics / primitive procedures, construct type equations using their types.\n-   For procedure expressions  `(lambda (p1 ... pn) e1 ... em)`, construct:\n\t\t-   `T_{(lambda (p1 ... pn) e1 ... em)} = [T_{p1} * ... * T_{pn} -> T_{em}]`\n-   For application expressions  `(op a1 ... an)`  construct:\n\t\t-   `T_{op} = [T_{a1} * ... * T_{an} -> T_{(op a1 ... an)}]`\n\n## Question 1\n\nTyping the expression  `((lambda (f1 x1) (f1 x1)) sqrt 4)`: =>  `((lambda ([f1 : Tf] [x1 : Tx]) : T2 (f1 x1)) sqrt 4)`\n\nNote: See how we added type anotations to the lambda's params, and return value.\n\n**Stage I**: Rename bound variables.\n\n`((lambda (f1 x1) (f1 x1)) sqrt 4)`  turn to  `((lambda (f x) (f x)) sqrt 4)`\n\n**Stage II**: Assign type variables for every sub expression:\n\n|Expression               \t    | Variable\n|-------------------------------|-----------------------------|\n((lambda (f x) (f x)) sqrt 4)\t|T0\n(lambda (f x) (f x))\t        |T1 \n(f x)\t                        |T2 \nf\t                            |Tf\nx\t                            |Tx\nsqrt\t                        |Tsqrt\n4\t                            |Tnum4\n\n\n**Stage III**: Construct type equations. \n\nThe equations for the sub-expressions are:\n\n|Expression               \t    | Equation\n|-------------------------------|-----------------------------|\n((lambda (f x) (f x)) sqrt 4)   |T1 = [Tsqrt * Tnum4 -> T0]\n(lambda (f x) (f x))\t        |T1 = [Tf * Tx -> T2]\n(f x)\t                        |Tf = [Tx -> T2]\n\n\nThe equations for the primitives are:\n\n|Expression               \t    | Equation\n|-------------------------------|-----------------------------|\nsqrt\t                        |Tsqrt = [Number -> Number]\n4                               |Tnum4 = Number\n\n**Stage IV**: Solve the equations.\n\n|Equation| Substitution\n|-------------------------------|-----------------------------|\n| 1. T1 = [Tsqrt * Tnum4 -> T0]\t| {}\n| 2. T1 = [Tf * Tx -> T2]\t    |\n| 3. Tf = [Tx -> T2]\t        |\n| 4. Tsqrt = [Number -> Number] |\t\n| 5. Tnum4 = Number             |\n\n\n**Step 1:**\n\n`(T1 = [Tsqrt * Tnum4-> T0]) \u25cb Substitution = (T1 = [Tsqrt * Tnum4-> T0])`  and is a type-sub.\n\n`Substitution = Substitution \u25cb (T1 = [Tsqrt * Tnum4-> T0])`.\n\n|Equation| Substitution\n| -------------------------------|-----------------------------|\n| 2. T1 = [Tf * Tx -> T2]\t     | {T1 := [Tsqrt * Tnum4 -> T0]}\n| 3. Tf = [Tx -> T2]             |\n| 4. Tsqrt = [Number -> Number]  |\t\n| 5. Tnum4 = Number              |\n\n**Step 2**:\n\n`T1 = [Tf * Tx -> T2] \u25cb Substitution = ([Tsqrt * Tnum4 -> T0] = [Tf * Tx -> T2])`\nThere is not type-sub since  both sides of the equation are composite **we split it into three** equations (6,7,8) and remove equation 2.\n\n|Equation| Substitution\n|-------------------------------|-----------------------------|\n| 3. Tf = [Tx -> T2]\t        | {T1 := [Tsqrt * Tnum4 -> T0]}\n| 4. Tsqrt = [Number -> Number]\t|\n| 5. Tnum4 = Number\t            |\n| 6. **Tf = Tsqrt**\t            |\n| 7. **Tx = Tnum4 (or Tnum4 = Tx)**\t|\n| 8. **T2 = T0**\t            |\n\n\n**Step 3:**\n\n`(Tf = [Tx -> T2]) \u25cb Substitution = (Tf = [Tx -> T2])`.\n`Substitution = Substitution \u25cb (Tf = [Tx -> T2])`.\n\n|Equation| Substitution\n|-------------------------------|-----------------------------|\n| 4. Tsqrt = [Number -> Number]\t| {T1 := [Tsqrt * Tnum4 -> T0],  **Tf := [Tx -> T2]**}\n| 5. Tnum4 = Number\t            |\n| 6. Tf = Tsqrt\t                |\n| 7. Tx = Tnum4 (or Tnum4 = Tx)\t|\n| 8. T2 = T0                    |\n\n\n**Step 4**:\n\n`(Tsqrt = [Number -> Number]) \u25cb Substitution = (Tsqrt = [Number -> Number])`.\n`Substitution = Substitution \u25cb (Tsqrt = [Number -> Number])`.\n\n|Equation| Substitution\n|-------------------------------|-----------------------------|\n|5. Tnum4 = Number\t            | { [T1 :=[**[Number -> Number]** * Tnum4->T0],<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Tf := [Tx -> T2], **Tsqrt := [Number -> Number]**}                                                    \n|6. Tf = Tsqrt                  |\n|7. Tx = Tnum4                  |\n|8. T2 = T0                     |\n\n\n**Step 5**:\n\n`(Tnum4 = Number) \u25cb Substitution = (Tnum4 = Number)`, is a type-sub.\n`Substitution = Substitution \u25cb (Tnum4 = Number)`.\n\n|Equation                       | Substitution\n|-----------------|-----------------------------|                             \n| 6. Tf = Tsqrt   | {  &nbsp;&nbsp;&nbsp; T1 :=[[Number -> Number] * **Number**->T0],\t <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Tf := [Tx -> T2], Tsqrt := [Number -> Number], <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  **Tnum4 := Number** &nbsp;&nbsp;&nbsp;}              \n| 7. Tx = Tnum4\t  |          \n| 8. T2 = T0      |\n\n**Step 6**:\n\n`(Tf = Tsqrt) \u25cb Substitution = ([Tx -> T2] = [Number -> Number])`\nThere is no a sub-type.\nWe split the equation into two equations (9,10) and remove equation 6.\n\n\n|Equation   | Substitution\n|------------------------------------------|-----------------------------|                                         \n|7. Tx = Tnum4                             | {  &nbsp;&nbsp;&nbsp; T1 :=[[Number -> Number] * Number->T0],\t <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Tf := [Tx -> T2], Tsqrt := [Number -> Number], <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  Tnum4 := Number &nbsp;&nbsp;&nbsp;}   \n|8. T2 = T0                                |\n|9. **Tx = Number**                        |\n|10. **T2 = Number**                       |\n\n\n\n**Step 7:**\n\n`(Tx = Tnum4) \u25cb Substitution = ([Tx = Number])`, type-sub.\n`Substitution = Substitution \u25cb ([Tx = Number])`.\n\n|Equation   | Substitution\n|------------------------------------------|-----------------------------|                             \n|8. T2 = T0                                |  {  &nbsp;&nbsp;&nbsp; T1 :=[[Number -> Number] * Number->T0],\t <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Tf := [**Number** -> T2], Tsqrt := [Number -> Number], <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  Tnum4 := Number, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; **Tx = Number**   &nbsp;&nbsp;&nbsp;}                  \n|9. Tx = Number                            |\n|10. T2 = Number                           |\n\n\n**Step 8:**\n\n`(T2 = T0) \u25cb Substitution = (T2 = T0)`, type-sub.\n`Substitution = Substitution \u25cb (T2 = T0)`.\n\n|Equation   | Substitution\n|------------------------------------------|-----------------------------|                             \n|9. Tx = Number   | {  &nbsp;&nbsp;&nbsp; T1 :=[[Number -> Number] * Number->T0],\t <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Tf := [Number-> **T0**], Tsqrt := [Number -> Number], <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  Tnum4 := Number, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Tx = Number,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  **T2 := T0** <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}                  \n|10. T2 = Number    |\n\n\n**Step 9:** \n`(Tx = Number) \u25cb Substitution = (Number = Number)` always true.\n\n\n|Equation   | Substitution\n|------------------------------------------|-----------------------------|                             \n|10. T2 = Number | {  &nbsp;&nbsp;&nbsp; T1 :=[[Number -> Number] * Number->T0],\t <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Tf := [Number-> T0], <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Tsqrt := [Number -> Number], <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  Tnum4 := Number, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Tx = Number , <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  T2 := T0 &nbsp;&nbsp;&nbsp;&nbsp;}                  \n\n\n**Step 10:**\n\n`(T2 = Number) \u25cb Substitution = (T0 = Number)`, type-sub.\n`Substitution = Substitution \u25cb (T0 = Number)`.\n\n|Equation   | Substitution\n|------------------------------------------|-----------------------------|                             \n| | {  &nbsp;&nbsp;&nbsp; T1 :=[[Number -> Number] * Number->**Number**],\t <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Tf := [Number-> **Number**], <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Tsqrt := [Number -> Number], <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  Tnum4 := Number, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Tx = Number , <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  T2 := **Number** <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  **T0 := Number**   &nbsp;&nbsp;&nbsp;&nbsp;}                  \n\n\nThe type inference succeeds since we have a type for T0, meaning that the expression is  **well typed**.\nSince there are no free variables, the inferred type of T0 is:  **Number.**\n\n**Note**: Our expression can be written now as  `((lambda ([f : (Number -> Number)] [x : Number]) : Number (f x)) sqrt 4)`\n\n## Question 2\n\nExtending the typing mechanism for if expressions: Recall the typing rule for if expressions shown in the typing system:\n\n```\n### Typing rule of If experession :\nFor every: type environment _Tenv, \n           expressions _p, _c, _a,\n           and type expressions Boolean, _Tif:\nIf         _Tenv \u22a2 _p:Boolean,\n           _Tenv \u22a2 _c:_Tif,\n           _Tenv \u22a2 _a:_Tif\nThen _Tenv \u22a2 (if _p _c _a):_Tif\n```\n\n\n#### Questions:\n\n-   If both consequence and alternative expressions had different types could we type the if expression?\n-   Do we need to add an equation for `_p`?\n\n\nFirst thing we notice from the rule is that the consequence expression (`_c`) and the alternative expression (`_a`) have the same type.\n\nGiven the first observation, the second thing we notice is that the type of the if expression is the type of the consequence expression.\n\nGiven the two observations we can add the following equations:\n\n```\nExpression\t Equation\n(if _p _c _a)\tT_p = Boolean\n                T_c = T_a\n            \tTif = T_c\n```\n  \nExample: type the expression `(if #t (+ 1 2) 3)`\n\n**Again**, look how we add type annotations.\n\n**Stage I**: Rename bound variables: No reference of variables so no renaming is needed.\n\n**Stage II**: Assign type variables for every sub expression:\n\n\n\n|Expression               \t    | Variable\n|-------------------------------|-----------------------------|\n|(if #t (+ 1 2) 3)\t            |T0\n|(+ 1 2)\t                    |T1\n|+\t                            |T+\n|#t\t                            |T#t\n|1\t                            |Tnum1\n|2\t                            |Tnum2\n|3\t                            |Tnum3\n\n\n\n**Stage III**: Construct type equations. The equations for the sub-expressions are:\n\n\n|Expression               \t    | Equation\n|-------------------------------|-----------------------------|\n|(if #t (+ 1 2) 3)\t        |T#t = Boolean\n|\t\t\t\t|T1 = Tnum3\n|                               |T0 = T1\n|(+ 1 2)\t                    |T+ = [Tnum1 * Tnum2 -> T1]\n\n\nThe equations for the primitives are:\n\n|Expression               \t    | Equation\n|-------------------------------|-----------------------------|\n|+\t                            |T+ = [Number * Number -> Number]\n|#t\t                            |T#t = Boolean\n|1\t                            |Tnum1 = Number\n|2\t                            |Tnum2 = Number\n|3\t                            |Tnum3 = Number\n\n\n**Stage IV** : Solve the equations:\n\n\n|Equation| Substitution\n|-------------------------------|-----------------------------|\n|1. T#t = Boolean\t        |{}\n|2. T1 = Tnum3\t                |\n|3. T0 = T1\t                    |\n|4. T+ = [Tnum1 * Tnum2 -> T1]\t|\n|5. T+ = [Number * Number -> Number] |\t\n|6. T#t = Boolean\t            |\n|7. Tnum1 = Number              |\t\n|8. Tnum2 = Number              |\t\n|9. Tnum3 = Number              |\n\n\n**Step 1:**\n\n`(T#t = Boolean) \u25cb Substitution = (T#t = Boolean)`, type-sub.\n\n`Substitution = Substitution \u25cb (T#t = Boolean)`.\n\n\n|Equation| Substitution\n|-------------------------------|-----------------------------|\n|2. T1 = Tnum3\t|   {&nbsp;&nbsp;&nbsp; **T#t = Boolean** &nbsp;&nbsp;&nbsp; }\n|3. T0 = T1\t                    |\n|4. T+ = [Tnum1 * Tnum2 -> T1]\t|\n|5. T+ = [Number * Number -> Number] |\t\n|6. T#t = Boolean\t            |\n|7. Tnum1 = Number              |\t\n|8. Tnum2 = Number              |\t\n|9. Tnum3 = Number              |\t\n\n\n**Step 2:**\n\n`(T1 = Tnum3) \u25cb Substitution = (T1 = Tnum3)`, type-sub.\n\n`Substitution = Substitution \u25cb (T1 = Tnum3)`.\n\n\n|Equation| Substitution\n|-------------------------------|-----------------------------|\n|3. T0 = T1\t|   {T#t = Boolean, **T1 := Tnum3**}\n|4. T+ = [Tnum1 * Tnum2 -> T1]\t|\n|5. T+ = [Number * Number -> Number] |\t\n|6. T#t = Boolean\t            |\n|7. Tnum1 = Number              |\t\n|8. Tnum2 = Number              |\t\n|9. Tnum3 = Number              |\t\n\n\n\n\n**Step 3:**\n\n`(T0 = T1) \u25cb Substitution = (T0 = Tnum3)`, type-sub.\n\n`Substitution = Substitution \u25cb (T0 = Tnum3)`.\n\n|Equation| Substitution\n|-------------------------------|-----------------------------|\n|4. T+ = [Tnum1 * Tnum2 -> T1]\t|   {&nbsp;&nbsp;&nbsp; T#t = Boolean,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; T1 := Tnum3,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; **T0 := Tnum3**  &nbsp;&nbsp;&nbsp; }\n|5. T+ = [Number * Number -> Number] |\t\n|6. T#t = Boolean\t            |\n|7. Tnum1 = Number              |\t\n|8. Tnum2 = Number              |\t\n|9. Tnum3 = Number              |\t\t\n\n\n**Step 4:**\n\n`(T+ = [Tnum1 * Tnum2 -> T1]) \u25cb Substitution = (T+ = [Tnum1 * Tnum2 -> Tnum3])`, type-sub.\n\n`Substitution = Substitution \u25cb (T+ = [Tnum1 * Tnum2 -> Tnum3])`.\n\n\n|Equation| Substitution\n|-------------------------------|-----------------------------|\n|5. T+ = [Number * Number -> Number] |\t {&nbsp;&nbsp;&nbsp; T#t = Boolean,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; T1 := Tnum3,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; T0 := Tnum3,  <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; **T+ = [Tnum1 * Tnum2 -> Tnum3]** &nbsp;&nbsp;&nbsp; }\n|6. T#t = Boolean\t            |\n|7. Tnum1 = Number              |\t\n|8. Tnum2 = Number              |\t\n|9. Tnum3 = Number              |\t\n\n\n**Step 5:**\n\n`(T+ = [Number * Number -> Number]) \u25cb Substitution = ([Tnum1 * Tnum2 -> Tnum3] = [Number * Number -> Number])`\n\nThere is not  a type-sub. \nWe split the equation to  `Tnum1 = Number, Tnum2 = Number and Tnum3 = Number`, \nand add them to the equations. Since they already exists,  **we only need to remove equation 5.**\n\n|Equation| Substitution\n|-------------------------------|-----------------------------|\n|6. T#t = Boolean\t|\t {&nbsp;&nbsp;&nbsp; T#t = Boolean,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; T1 := Tnum3,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; T0 := Tnum3,  <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; T+ = [Tnum1 * Tnum2 -> Tnum3] &nbsp;&nbsp;&nbsp; }\n|7. Tnum1 = Number              |\t\n|8. Tnum2 = Number              |\t\n|9. Tnum3 = Number              |\t\t\n\n\n**Step 6:** \n`(T#t = Boolean) \u25cb Substitution = (Boolean = Boolean)` always true.\n\n|Equation| Substitution\n|-------------------------------|-----------------------------|\n|7. Tnum1 = Number              |\t {&nbsp;&nbsp;&nbsp; T#t = Boolean,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; T1 := Tnum3,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; T0 := Tnum3,  <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; T+ = [Tnum1 * Tnum2 -> Tnum3] &nbsp;&nbsp;&nbsp; }\t\n|8. Tnum2 = Number              |\t\n|9. Tnum3 = Number              |\t\t\n\nSkipping the trivial steps, we get:\n\n|Equation| Substitution\n|-------------------------------|-----------------------------|\n| | { &nbsp;&nbsp;&nbsp;  T#t := Boolean,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;T1 := **Number**,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; T0 := **Number**,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;**Tnum1 := Number**,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;**Tnum2 := Number**,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;**Tnum3 := Number**,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; T+ := [Number * Number -> Number]&nbsp;&nbsp;&nbsp; }\n\n\nThe type inference succeeds, meaning that the expression is  **well typed**.\nBecause there are no free variables, the inferred type of T0 is:  **Number**.\n\n## Question 3\n\nTyping the application `((lambda (f1 x1) (f1 x1)) 4 sqrt)`:\n\n**Stage I**: Rename bound variables.\n\n`((lambda (f1 x1) (f1 x1)) 4 sqrt)`  turns into  `((lambda (f x) (f x)) 4 sqrt)`\n\n**Stage II**: Assign type variables for every sub expression and primitives:\n\n|Expression\t               | Variable\n|-------------------------------|------------|\n((lambda (f x) (f x)) 4 sqrt)   |T0\n(lambda (f x) (f x))\t        |T1\n(f x)\t                        |T2\nf\t                            |Tf\nx\t                            |Tx\n4\t                            |Tnum4\nsqrt\t                        |Tsqrt\n\n**Stage III**: Construct type equations.\n\n The equations for the sub-expressions are:\n\n|Expression               \t    | Equation\n|-------------------------------|-----------------------------|\n|((lambda (f x) (f x)) 4 sqrt)   |T1 = [Tnum4 * Tsqrt -> T0]\n|(lambda (f x) (f x))\t        |T1 = [Tf * Tx -> T2]\n|(f x)                     \t    |Tf = [Tx -> T2]\n\nThe equations for the primitives are:\n\n|Expression               \t    | Equation\n|-------------------------------|-----------------------------|\n|4\t                            |Tnum4 = Number\n|sqrt\t                        |Tsqrt = [Number -> Number]\n\n**Stage IV**: Solve the equations.\n\n|Equation                       | Substitution\n|-------------------------------|-----------------------------|\n|1. T1 = [Tnum4 * Tsqrt -> T0]\t|{}\n|2. T1 = [Tf * Tx -> T2]\t    |\n|3. Tf = [Tx -> T2]\t            |\n|4. Tnum4 = Number\t            |\n|5. Tsqrt = [Number -> Number]  |\t\n\n**Step 1:**  \n\n`(T1 = [Tnum4 * Tsqrt -> T0]) \u25cb Substitution = (T1 = [Tnum4 * Tsqrt -> T0])`, type-sub.  \n\n`Substitution = Substitution \u25cb (T1 = [Tnum4 * Tsqrt -> T0]).`\n\n\n|Equation| Substitution\n|-------------------------------|-----------------------------|\n|2. T1 = [Tf * Tx -> T2]\t    |{ &nbsp;&nbsp;&nbsp; **T1 := [Tnum4 * Tsqrt -> T0]** &nbsp;&nbsp;&nbsp;}\n|3. Tf = [Tx -> T2]\t            |\n|4. Tnum4 = Number\t            |\n|5. Tsqrt = [Number -> Number]  |\t\n\n**Step 2:**\n\n`(T1 = [Tf * Tx -> T2]) \u25cb Substitution = ([Tf * Tx -> T2] = [Tnum4 * Tsqrt -> T0])`\n\nThere is no type-sub. We split the equation to\n\n* Tf = Tnum4, \n* Tx = Tsqrt, \n* T2 = T0\n\nWe add them to the equations (6,7,8) and remove equation 2.\n\n|Equation| Substitution\n|-------------------------------|-----------------------------|\n|3. Tf = [Tx -> T2]  \t        |{ &nbsp;&nbsp;&nbsp; T1 := [Tnum4 * Tsqrt -> T0] &nbsp;&nbsp;&nbsp;}\n|4. Tnum4 = Number\t            |\n|5. Tsqrt = [Number -> Number]  |\t\n|6.  **Tf = Tnum4**\t            |\n|7.  **Tx = Tsqrt**\t            |\n|8.  **T2 = T0**\t            |\n\n\n**Step 3:**\n\n`(Tf = [Tx -> T2]) \u25cb Substitution = (Tf = [Tx -> T2])` , type-sub.\n`Substitution = Substitution \u25cb (Tf = [Tx -> T2])`.\n\n|Equation| Substitution\n|-------------------------------|-----------------------------|\n|4. Tnum4 = Number\t            |  { &nbsp;&nbsp;&nbsp; T1 := [Tnum4 * Tsqrt -> T0], <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  **Tf = [Tx -> T2]** &nbsp;&nbsp;&nbsp;}\n|5. Tsqrt = [Number -> Number]  |\t\n|6.  Tf = Tnum4\t                |\n|7.  Tx = Tsqrt                 |\n|8.  T2 = T0\t                |\n\n\n**Step 4:** \n\n`(Tnum4 = Number) \u25cb Substitution = (Tnum4 = Number)`, type-sub.\n\n`Substitution = Substitution \u25cb (Tnum4 = Number)`.\n\n|Equation| Substitution\n|-------------------------------|-----------------------------|\n|5. Tsqrt = [Number -> Number]  |\t  { &nbsp;&nbsp;&nbsp; T1 :=[**Number** * Tsqrt -> T0], <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  Tf = [Tx -> T2], <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; **Tnum4 = Number** &nbsp;&nbsp;&nbsp;}\n|6.  Tf = Tnum4\t                |\n|7.  Tx = Tsqrt                 |\n|8.  T2 = T0\t                |\n\n\n**Step 5:**\n\n`(Tsqrt = [Number -> Number]) \u25cb Substitution = (Tsqrt = [Number -> Number])` , type-sub.\n`Substitution = Substitution \u25cb (Tsqrt = [Number -> Number])`.\n\n\n|Equation| Substitution\n|-------------------------------|-----------------------------|\n|6.  Tf = Tnum4\t                |  { &nbsp;&nbsp;&nbsp; T1 :=[Number * **[Number -> Number]**-> T0], <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  Tf = [Tx -> T2], <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Tnum4 = Number <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  **Tsqrt := [Number->Number]** &nbsp;&nbsp;&nbsp;}\n|7.  Tx = Tsqrt                 |\n|8.  T2 = T0\t                |\n\n\n**Step 6:**  \n\n`(Tf = Tnum4) \u25cb Substitution = ([Tx -> T2] = Number)`  \n\nWe get the conflicting equation:\n\n`[Tx -> T2] = Number` and we can say that the expression is **not well typed.**\n\n\n"
    }
]