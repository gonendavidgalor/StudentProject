[
    {
        "name": "ps1.md",
        "content": "# TypeScript: Complex Data Types, JSON, Map, Filter, Reduce\n\n## PPL 2023 - [Course Website](https://bguppl.github.io/interpreters/)\n## Practical Session - Week #1\n\n### How to Install Node.js and NPM on Windows\n\nNode.js is a JavaScript interpreter. NPM (Node Package Manager) let's you install software (libraries, plugins, frameworks and applications) used to build Node applications. Both are installed using the installer package avaiable from the Node.js web site. The isntallation is pretty straightforward: \n\n1. Download the LTS (version 18) Windows installer from [nodejs.org](https://nodejs.org/en/)\n2. Run the installer (the .msi file you downloaded in the previous step.)\n3. Follow the prompts in the installer (Accept the license agreement, click the NEXT button a bunch of times and accept the default installation settings).\n4. Restart your computer.\n\n#### Test the installation: \n* Open the Windows Command Prompt (press the Win + R keys. Then, type `cmd` and press Enter).\n* To verify node is installed, type `node -v`, then press Enter. You should see a version number (should start with 'v16.').\n* To verify NPM installation, type `npm -v` and press Enter. You should see a version number (should start with '8.').\n\n#### More information:\nFor instructions on how to install other software that will be used throughout the course, please refer to the [useful links](https://bguppl.github.io/interpreters/useful_links.html) section in the course web site.  In particular, see instructions on how to install the TypeScript compiler `tsc` and the Visual Studio Code IDE.\n\n## 1. Types of Values\n\nA **data-type** is a classification of data which indicates what the programmer intends to do with the data. Types correspond to a set of values (eg. the boolean type corresponds to {true,false}, number type corresponds to the infinite set of numeric values), and they define the operations that can be done on the data (e.g. booleans can be computed using logical operators).\n\nWe pay attention to two distinguishable defintions: The **type of a value** (atomic/compound) and the **type of a variable**. The type of a variable may be declared by the programmer of inferred by the type of the value it stores. The type of a value is determined by a defined group to which it belongs. The type of a variable may be different than the type of the value it stores, but they must be compatiable.\n\nApart from atomic types (number, string, boolean), there are **compound types**. Javascript introduces two basic compound types: Arrays and Maps. In Javascript, compound types are called *object* types (note: not to be confused with the more standard term - *object* here simply refers to any value which is not an atomic type)\n\n##### Arrays\n\nArrays are the first basic compound type in Javascript. Here is an example of using arrays:\n\n\n```typescript\n// This is how we declare an array containing the elements 16,8,27,13\nlet a = [16, 8, 27, 13];\n\n// Here's how we use the Array compound value getter:\nconsole.log(a[3]); // ==> 13\n\n// There is also a slice method:\nconsole.log(a.slice(1, 4)); // ==> [ 8, 27, 13 ]\n```\n\n\nLet's check that it is a compound type:\n\n\n```typescript\nconsole.log(typeof a); // ==> 'object'\n```\n\nAnd now the more specific reflection operator: \n\n\n```typescript\nconsole.log(a instanceof Array); // ==> true\n```\n\nThe array we defined above is **homogeneous**, meaning that it contains a single data type. \nThe **homogeneous** array `a` above contains values whose types are `number`. \nArrays in Javascript can be heterogeneous as well: \n\n\n```typescript\nlet manyArray = [1, 'a', '2', \"The Dawn\", true];\n\nconsole.log(`manyArray = ${manyArray}`); // ==> manyArray = 1,a,2,The Dawn,true\n```\n\n##### Maps and `Object.keys`\n\nMaps are the second basic compound type in Javascript:\n\n```typescript\n// This is how we declare them\nlet map = { a: 1, b: 2 };\n\n// This is how we use the Map compound value getter for the values:\nconsole.log(map['a']); // ==> 1\nconsole.log(map.a); // ==> 1\nconsole.log(map['b']); // ==> 2\nconsole.log(map.b); // ==> 2\n\n// And for keys (relevant for both Arrays [the keys there are the indexes] and Maps)\nconsole.log(Object.keys(a)); // ==> [ '0', '1', '2', '3', '4' ]\nconsole.log(Object.keys(map)); // ==> [ 'a', 'b' ]\n```\n\n##### Variable Types\n\nJavascript is a *dynamic language*, meaning that variables are not typed. But when a variable is bound to a value, we can inspect its type at runtime. \n\nTypescript extends Javascript to introduce optional variable types - it is compiled into Javascript and at compilation time, type checking is performed. Let's recall the example from the lectures: \n\n\n```typescript\nlet typedVarNum: number = 6;\nlet typedVarStr: string = \"blue\";\nlet typedVarBool: boolean = true;\n```\n\n## 2. JSON\n\n### 2.1 JSON Review\n\nJSON stands for JavaScript Object Notation and is a standard way to serialize Javascript compound values into strings (and vice-versa). It is widely used to allow data exchange in server-client communication. It serves a role that is similar to XML.\n\nJSON is a **notation** - that is, a way of writing Javascript values in a way that allows reading them back easily. \nMost Javascript values can be written in JSON - but not all of them.\n\nOnce you have a Javascript object, and once there is an agreed-upon-way of \"stringifying\" the object (in our case, the standard way is `JSON.stringify()`), then you can easily pass this string through the network, from a computer to a computer, as passing strings through the network is easy, and the receiving side can only do an agreed-upon way to parse the string into an object (in our case, the standard way is `JSON.parse()`).\n\nThe JSON interface defines the following two methods: \n1. `JSON.stringify(o)` - maps a value to a string\n2. `JSON.parse(s)` - maps a string written according to the JSON syntax to a value\n\nJSON serves a similar goal to that of `Serializable` of Java that we saw in SPL.\n\n\n```typescript\nlet person1 = { name : \"Yosi\", age : 31, city : \"Beer Sheva\" };\nlet person1JSONString = JSON.stringify(person1);\n\nconsole.log(`person1 serialized in JSON = ${person1JSONString}`); // ==> person1 serialized in JSON = {\"name\":\"Yosi\",\"age\":31,\"city\":\"Beer Sheva\"}\nconsole.log(`person1JSONString is of type ${typeof person1JSONString}`); // ==> person1JSONString is of type string\n```\n\n```typescript\nlet person2 = JSON.parse(person1JSONString);\n\nconsole.log(person2); // ==> { name: 'Yosi', age: 31, city: 'Beer Sheva' }\nconsole.log(`person2 is of type ${typeof person2}`); // ==> person2 is of type object\n```\n\nNote that the way values are written in JSON is not exactly the same as we write them in a Javascript program - there are quotes (\"\") around keys for example.\n\nNote also that `stringify()` and `parse()` work on atomic values as well:\n\n\n```typescript\n// note that the input to JSON.parse is a JSON string\nconsole.log(typeof JSON.parse('2')); // ==> number\nconsole.log(typeof JSON.parse('true')); // ==> boolean\nconsole.log(typeof JSON.parse('\"abc\"')); // ==> string\n```\n\nThe values that can be encoded into JSON (let us call them \"JSON values\") must be one of the following types:\n1. `string`\n2. `number`\n3. `boolean`\n4. `null`\n5. a map where all the keys are strings and all the values are JSON values (recursively) \n6. an array where all the values are JSON values\n\nThe Javascript compound data types, *arrays* and *maps*, can be combined in a recursive manner. \nThis applies to JSON as well.\n\nThe Javascript values that **cannot be encoded** into JSON strings are `undefined` and functions.\n\nLet us look at an example of a complex value and how we can describe it in JSON and then how using types can help us describe its structure in a well-documented manner:\n\n\n```typescript\nlet studentsData = {\n    department: \"Computer Science\", \n    students: [\n        { name: \"Alice\", degree: \"PhD\" }\n        { name: \"Bob\", degree: \"MSc\" },\n    ]\n};\n\nlet studentsJSON = JSON.stringify(studentsData);\nconsole.log(studentsJSON); // ==> {\"department\":\"Computer Science\",\"students\":[{\"name\":\"Alice\",\"degree\":\"PhD\"},{\"name\":\"Bob\",\"degree\":\"MSc\"}]}\nconsole.log(`studentsJSON is of type ${typeof studentsJSON}`); // ==> studentsJSON is of type string\nlet studentsJSONParsed = JSON.parse(studentsJSON);\nconsole.log(studentsJSONParsed);\n// ==> \n// {\n//   department: 'Computer Science',\n//   students: [ { name: 'Alice', degree: 'PhD' }, { name: 'Bob', degree: 'MSc' } ]\n// }\nconsole.log(`studentsJSONParsed is of type ${typeof studentsJSONParsed}`); // ==> studentsJSONParsed is of type object\n```\n\nWe verified that this complex structure can be written into JSON, and then parsed back into an identical value (this is a **round-trip** that preserves the value).\n\nWe can look at the type of `studentData` as a **tree** of simpler values:\n* `studentsData` is a map which has 2 keys:\n  * `department` with a value which is a string\n  * `students` with a value which is an embedded array whose items are compound values.\n* The nested values are maps that have 2 keys:\n  * `name` whose value is a `string` \n  *  `degree` whose value is also a `string`\n  \n\n### 2.2 Documenting Complex Values with Type Annotations\n\nWe can describe this structure using the following TypeScript declaration:\n\n```typescript\n{\n    department: string;\n    students: { name: string, degree: string }[]\n}\n```\n\nThis can be made more readable if we name the types, using the **type alias** TypeScript construct to name map compound types:\n\n\n```typescript\ntype Student = {\n    name: string;\n    degree: string;\n}\n\ntype StudentsData = {\n    department: string;\n    students: Student[];\n}\n```\n\nThis type definition is useful to document the type of the expected values that we expect to read.\n\n### 2.3 Working on complex JSON values\n\nIn this section, we will use the methods **map**, **filter**, **reduce** to operate over complex JSON values. \n\nWe will take a videos-database example ([http://reactivex.io/learnrx/](http://reactivex.io/learnrx/)) as a basis for our examples.\n\nSuppose you are a developer at the popular streaming-movie website Netflix, and that your system's *API* uses JSON to communicate data. The JSON values we describe are actual JSON values returned by the Netflix API.\n\nWhen searching for new movie releases, you send a query to the API, and obtain a JSON reply:\n\n\n```typescript\nlet newReleases = [\n        {\n            \"id\": 70111470,\n            \"title\": \"Die Hard\",\n            \"boxart\": \"http://cdn-0.nflximg.com/images/2891/DieHard.jpg\",\n            \"uri\": \"http://api.netflix.com/catalog/titles/movies/70111470\",\n            \"rating\": 4.0,\n            \"bookmark\": []\n        },\n        {\n            \"id\": 654356453,\n            \"title\": \"Bad Boys\",\n            \"boxart\": \"http://cdn-0.nflximg.com/images/2891/BadBoys.jpg\",\n            \"uri\": \"http://api.netflix.com/catalog/titles/movies/70111470\",\n            \"rating\": 5.0,\n            \"bookmark\": [{ id: 432534, time: 65876586 }]\n        },\n        {\n            \"id\": 65432445,\n            \"title\": \"The Chamber\",\n            \"boxart\": \"http://cdn-0.nflximg.com/images/2891/TheChamber.jpg\",\n            \"uri\": \"http://api.netflix.com/catalog/titles/movies/70111470\",\n            \"rating\": 4.0,\n            \"bookmark\": []\n        },\n        {\n            \"id\": 675465,\n            \"title\": \"Fracture\",\n            \"boxart\": \"http://cdn-0.nflximg.com/images/2891/Fracture.jpg\",\n            \"uri\": \"http://api.netflix.com/catalog/titles/movies/70111470\",\n            \"rating\": 5.0,\n            \"bookmark\": [{ id: 432534, time: 65876586 }]\n        }\n    ];\n```\n\nLet us describe the **type** of this value:\n* We observe it is a homogeneous array of map values.\n* Each map value describes a \"movie\" with fields id, title, boxart, uri, rating and bookmark.\n\nThe corresponding TypeScript annotation is:\n\n```typescript\ntype Video = {\n    id: number;\n    title: string;\n    boxart: string;\n    uri: string;\n    rating: number;\n    bookmark: { id: number, time: number }[];\n}\n\ntype Releases = Video[];\n```\n\nThis type annotation lets us think about the data we obtained from the API as an array `[v1, v2, v3, v4]` where each item $$v_i$$ is a map `{ id, title, boxart, uri, rating, bookmark }`.\n\n\n#### 2.3.1 Map over an Array of Videos\n\nWe would like to transform this data into an array of `{ id, title }` properties. \nThis transformation is called a **projection** as we select only some of the properties in the input.\n\nIn terms of types, this transformation maps from the type `Video[]` into the type `{ id: number, title: string }[]`.\n\nA procedural way to achieve this goal would be:\n\n\n```typescript\nfunction getIDsAndTitles_1(reply) {\n    let res = [];\n    for (let i = 0; i < reply.length; i++) {\n        res.push({ id: reply[i].id, title: reply[i].title });\n    }\n    return res;\n}\n\nlet newReleasesIDAndTitle = getIDsAndTitles_1(newReleases);\nconsole.log(newReleasesIDAndTitle);\n// ==> \n// [ { id: 70111470, title: 'Die Hard' },\n//   { id: 654356453, title: 'Bad Boys' },\n//   { id: 65432445, title: 'The Chamber' },\n//   { id: 675465, title: 'Fracture' } ]\n```\n\nA functional way of achieving the same result uses the **map** method (seen in the reading material for week 1) to abstract away the loop and the mutations we observe in the procedural solution (`i++`, `res.push()`).\n\n```typescript\nlet newReleasesIDAndTitle = newReleases.map(x => ({ id: x.id, title: x.title }));\nconsole.log(newReleasesIDAndTitle);\n// ==> \n// [ { id: 70111470, title: 'Die Hard' },\n//   { id: 654356453, title: 'Bad Boys' },\n//   { id: 65432445, title: 'The Chamber' },\n//   { id: 675465, title: 'Fracture' } ]\n```\n\nNote that in this version:\n* There is no loop (`map` abstracts away the loop control structure)\n* There is no variable assignment (no need to define a loop counter `i` and mutate it and to maintain a `res` accumulator variable).\n\nLet us note what is the type of the transformer function we pass as an argument to `map`:\nit gets as an argument `x` an item from `newReleases` - which is of type `Video` - and it returns a map of type `{ id: number, name: title }`.  \n\n#### 2.3.2 Filter an Array of Videos\n\nThe user is quite picky, and would like to search for new releases that have a rating of 5.0 only. \n\nWe can solve this problem using **filter**.\n\nIn terms of types, the operation we want to define maps an array of `Video[]` to an array of `Video[]`.\nThis fits the definition of `filter` - which does not change the type of items in the array.\n\n```typescript\nlet newReleasesOfRating5 = newReleases.filter(x => x.rating === 5);\nconsole.log(newReleasesOfRating5);\n// ==>\n// [ { id: 654356453,\n//     title: 'Bad Boys',\n//     boxart: 'http://cdn-0.nflximg.com/images/2891/BadBoys.jpg',\n//     uri: 'http://api.netflix.com/catalog/titles/movies/70111470',\n//     rating: 5,\n//     bookmark: [ [Object] ] },\n//   { id: 675465,\n//     title: 'Fracture',\n//     boxart: 'http://cdn-0.nflximg.com/images/2891/Fracture.jpg',\n//     uri: 'http://api.netflix.com/catalog/titles/movies/70111470',\n//     rating: 5,\n//     bookmark: [ [Object] ] } ]\n```\n\n#### 2.3.4 Reminder: Reduce and Neutral Elements as Initializers\nCompare the following 5 invocations of `reduce`:\n\n```typescript\n// Compute the sum of an array of integers\n[1, 2, 3].reduce((acc, cur) => acc + cur, 0); // ==> 6\n\n// Compute the product of an array of integers\n[1, 2, 3].reduce((acc, cur) => acc * cur, 1); // ==> 6\n\n// Compute the logical and of an array of booleans\n[true, false, true].reduce((acc, cur) => acc && cur, true); // ==> false\n\n// Compute the logical or of an array of booleans\n[true, false, true].reduce((acc, cur) => acc || cur, false); // ==> true\n\n// Compute the max of an array of numbers\n[3, 1, 4].reduce((acc,cur) => Math.max(acc,cur), 0); // ==> 4\n```\n\nNote that in all 5 cases, the initializer passed to `reduce(reducer, init)` is the neutral element of the reducer operator (0 for `+`, 1 for `*`, `true` for `and`, `false` for `or`).\n\nThis makes sense in general - and allows one to answer the puzzling question of **what should be the value of reduce when applied to an empty array**.  The general answer is that it should be the neutral element of the reducer.\n\n**NOTE**: the `max` version takes as an initializer the value 0.  This is not correct when the array can contain negative numbers.  What should be the initial value in this case?\n\n#### 2.3.5 Rectangle Selection with Reduce\n\nA user has chosen to view movies as boxarts (that is, the image that is shown for each movie), as it is easier to select movies according to their boxarts. The API returned the following value as a reply to our query:\n\n\n```typescript\nlet boxarts = [\n    { width: 200, height: 200, url: \"http://cdn-0.nflximg.com/images/2891/Fracture200.jpg\" },\n    { width: 150, height: 200, url: \"http://cdn-0.nflximg.com/images/2891/Fracture150.jpg\" },\n    { width: 300, height: 200, url: \"http://cdn-0.nflximg.com/images/2891/Fracture300.jpg\" },\n    { width: 425, height: 150, url: \"http://cdn-0.nflximg.com/images/2891/Fracture425.jpg\" }\n]\n```\n\nLet us define the type of this returned value: it is a homogeneous array of maps. Each map describes a boxart.\n\n```typescript\ntype Boxart = {\n    width: number; \n    height: number;\n    url: string;\n}\n```\n\nWe would like to find the largest box-art image size, so that we could know what is the maximal size of the image placeholder should be.  We measure rectangles by their area ($$width \\times height$$).\n\nA straightforward way to do this is by going over each boxart, and keeping a temporary variable that holds the largest size out of the boxarts we have seen so far.\n\nIn terms of types, the transformation maps an array `Boxart[]` into a `number`. Let us annotate this type into the function definition:\n\n\n```typescript\ntype Boxart = {\n    width: number; \n    height: number;\n    url: string;\n}\n\nfunction maxBox(boxes: Boxart[]): number {\n    let maxBox = 0;\n    for (let i = 0; i < boxes.length; i++) {\n        let curBoxSize = boxes[i].width * boxes[i].height;\n        if (curBoxSize > maxBox) {\n            maxBox = curBoxSize;\n        }\n    }\n    return maxBox;\n}\nmaxBox(boxarts); // ==> 63750\n```\n\nThis is a case of a loop to accumulate a value from an array of values. In terms of types, it maps an array to a single value. The **reduce** method fits perfectly for this scenario: The `reduce` method takes as parameter a reducer function and an initial value, and returns the accumulated value. \n\nThe reducer function takes two arguments: the current accumulator, and the current item. The return value of the reducer function is the \"successive\" value of the accumulator parameter. That is, the result of some operation applied to the current accumulator, and the current item.\n\nOur current accumulator should be the current largest box-art image size, and the initial value should be 0.\n\n```typescript\nlet largestBoxartSize = boxarts.reduce(\n    (curMax,curBox) => {\n        let curBoxSize = curBox.width * curBox.height;\n           if (curBoxSize > curMax) {\n               return curBoxSize;\n           } else {\n               return curMax;\n           }\n    }, // this is the reducer function\n    0  // this is the initial value\n    );\n    \nconsole.log(largestBoxartSize); // ==> 63750\n```\n\nIndeed, the largest boxart image size is 63750, which is the 4th boxart.\n\nNote that this version has no side effect, no mutation and no loop.\n\nWe can make this version more readable by using the Math.max function - to express clearly that what we are doing in this `reduce` invocation is the identification of the max of an array.  We also annotate the expected type of the parameters in the reducer.\n\n```typescript\nconst boxSize = (box: Boxart) => box.width * box.height;\nlet maxBoxSize = boxarts.reduce((curMax: number, curBox: Boxart) => Math.max(curMax, boxSize(curBox)), 0);\n\nconsole.log(maxBoxSize); // ==> 63750\n```\n\n### 2.4 Tree Values\n\nSome replies will be more complex than what we have witnessed above: it is very often that we face replies that have a **tree** form, as opposed to a flat homogeneous array.\n\nOne example of such, is the following API reply - which returns values grouped by movie genre (\"New Releases\", \"Dramas\" ...)\n\n```typescript\nlet movieLists = [\n        {\n            name: \"New Releases\",\n            videos: [\n                {\n                    \"id\": 70111470,\n                    \"title\": \"Die Hard\",\n                    \"boxart\": \"http://cdn-0.nflximg.com/images/2891/DieHard.jpg\",\n                    \"uri\": \"http://api.netflix.com/catalog/titles/movies/70111470\",\n                    \"rating\": 4.0,\n                    \"bookmark\": []\n                },\n                {\n                    \"id\": 654356453,\n                    \"title\": \"Bad Boys\",\n                    \"boxart\": \"http://cdn-0.nflximg.com/images/2891/BadBoys.jpg\",\n                    \"uri\": \"http://api.netflix.com/catalog/titles/movies/70111470\",\n                    \"rating\": 5.0,\n                    \"bookmark\": [{ id: 432534, time: 65876586 }]\n                }\n            ]\n        },\n        {\n            name: \"Dramas\",\n            videos: [\n                {\n                    \"id\": 65432445,\n                    \"title\": \"The Chamber\",\n                    \"boxart\": \"http://cdn-0.nflximg.com/images/2891/TheChamber.jpg\",\n                    \"uri\": \"http://api.netflix.com/catalog/titles/movies/70111470\",\n                    \"rating\": 4.0,\n                    \"bookmark\": []\n                },\n                {\n                    \"id\": 675465,\n                    \"title\": \"Fracture\",\n                    \"boxart\": \"http://cdn-0.nflximg.com/images/2891/Fracture.jpg\",\n                    \"uri\": \"http://api.netflix.com/catalog/titles/movies/70111470\",\n                    \"rating\": 5.0,\n                    \"bookmark\": [{ id: 432534, time: 65876586 }]\n                }\n            ]\n        }\n    ]\n```\n\nTo document the structure of this value, let us write its type:\n* It is an array of 2 maps of identical structure.\n* Each item represents a category of Videos. The category maps have the following keys:\n  * name: string\n  * videos: an array of Video.\n\nThe TypeScript definition is thus:\n\n```typescript\ntype VideoCategory = {\n    name: string;\n    videos: Video[];\n}\ntype VideoCategories = VideoCategory[];\n```\n\nThe structure of the value is thus a *tree*: $$[ category_1, category_2 ]$$ where $$category_i$$ is of the form:<br>\n`{ name: string, videos: [v1,...] }`.\n\nThese kinds of trees impose a challenge when working with them: if we apply `map` or `filter`, the transformer or the predicate will receive as argument a `VideoCategory` object.  If we want to process the embedded `Video` objects inside the categories, we must first **flatten** the tree.\n\nSuppose we would like to have a list of all movie ids in that tree. The most trivial way, as before, is to do the following (using a foreach loop):\n\n```typescript\nlet movieIds = []\nmovieLists.forEach(category => category.videos.forEach(video => movieIds.push(video.id)));\nconsole.log(`movieIds=${movieIds}`); // ==> movieIds=70111470,654356453,65432445,675465\n```\n\n`forEach` abstracts a single loop. The embedded calls to `forEach` inside `forEach` reflects the two-level traversal of the tree.\n\nNote that `forEach` is **not a functional** style: this is precisely the type of operations we want to abstract away using map/filter/reduce. This version has an accumulator variable (`movieIds`) which we must initialize and then mutate as part of the `forEach` iteration.\n\nNot a functional solution...\n\nThe general feeling of the task we want to perform is an **accumulation** - so that `reduce` seems to be the good tool. But we cannot apply `reduce` as is, because `reduce` would work on `Category` values and we want to accumulate `Video` values.\n\nAlternatively, we could attempt to use **map** as we are mapping `Video` values into `number` values.  But again, we cannot map over Categories - we need to map over Videos - so that `map` cannot be used directly.\n\nLet's recall the `concat` method of arrays:\n\n```typescript\nlet arrayOne = [1, 2, 3, 4];\nlet arrayTwo = [5, 6, 7, 8];\narrayOne.concat(arrayTwo); // ==> [ 1, 2, 3, 4, 5, 6, 7, 8 ]\n```\n\nIn contrast to `push`, `concat` does not mutate its arguments - it returns a new array and can be used safely.\n\nIf we `reduce` an array of arrays and accumulate using the `concat` operator,  we will get a method that flattens one level of an array of arrays:\n\n```typescript\nlet a = [[1, 2, 3], [4, 5, 6]];\na.reduce((acc, curr) => acc.concat(curr), []); // ==> [ 1, 2, 3, 4, 5, 6 ]\n```\n\nWe now need to apply a mixture of `map` and `reduce` in order to map and flatten:\n\n```typescript\n// We want the following as an array of the numbers:\nlet a = [{ group: 1, numbers: [1, 2, 3] }, { group: 2, numbers: [4, 5, 6] }];\na.map(x => x.numbers).reduce((acc,curr) => acc.concat(curr), []); // ==> [ 1, 2, 3, 4, 5, 6 ]\n```\n\n### 2.4.1 The Ramda package\n\nRamda is a library of functions designed to facilitate functional programming in JavaScript.\n\nRamda includes a function called `chain` (often also called `flatmap`) which can come handy in our last example: If we want to return all of the results as a single flat array instead of as an array of arrays, then we can use Ramda's `chain`:\n\n```typescript\nimport * as R from \"ramda\";\n\nR.chain(x => x.numbers, a); // ==> [ 1, 2, 3, 4, 5, 6 ]\n```\n\nThe `chain` function goes through an array, and flattens the result of 'doing something' (which can be 'nothing' or applying a 'mapping') by one level.\n\nBack to our videos example, if we `chain` the `movieLists` with a function that just returns the category videos, then the result would be an array containing the videos. As such:\n\n```typescript\nR.chain(category => category.videos, movieLists);\n// ==>\n// [ { id: 70111470,\n//     title: 'Die Hard',\n//     boxart: 'http://cdn-0.nflximg.com/images/2891/DieHard.jpg',\n//     uri: 'http://api.netflix.com/catalog/titles/movies/70111470',\n//     rating: 4,\n//     bookmark: [] },\n//   { id: 654356453,\n//     title: 'Bad Boys',\n//     boxart: 'http://cdn-0.nflximg.com/images/2891/BadBoys.jpg',\n//     uri: 'http://api.netflix.com/catalog/titles/movies/70111470',\n//     rating: 5,\n//     bookmark: [ [Object] ] },\n//   { id: 65432445,\n//     title: 'The Chamber',\n//     boxart: 'http://cdn-0.nflximg.com/images/2891/TheChamber.jpg',\n//     uri: 'http://api.netflix.com/catalog/titles/movies/70111470',\n//     rating: 4,\n//     bookmark: [] },\n//   { id: 675465,\n//     title: 'Fracture',\n//     boxart: 'http://cdn-0.nflximg.com/images/2891/Fracture.jpg',\n//     uri: 'http://api.netflix.com/catalog/titles/movies/70111470',\n//     rating: 5,\n//     bookmark: [ [Object] ] } ]\n```\n\nThe only change that is left, is that we do not want the category videos flattened, rather something extra: taking the `category.videos` and mapping each element there to its `id`.\n\n```typescript\nR.chain(category => category.videos, movieLists).map(video => video.id); // ==> [ 70111470, 654356453, 65432445, 675465 ]\n```\n\nIt helps to annotate the types of the arguments in such chained transformations to document and verify their correctness:\n\n```typescript\nR.chain((category: VideoCategory) => category.videos, movieLists).map((video: Video) => video.id); // ==> [ 70111470, 654356453, 65432445, 675465 ]\n```\n\n## 3. Exercises\n\n### 3.1 Implement the `map` method using `reduce`\n\nLet's think step by step: What should be our *accumulated* value? It is natural to think that the accumulation consists in 'pushing' the current element **as a mapped value** to the currently accumulated array.\n\nTo that end, the initial value should be the empty array. As we go, we will take the current element, and our next accumulator will be the current accumulator, only expanded by the current element after it is mapped by the transformer.\n\n[Solution](./ps1_sol.html#exercise-1-implementing-map-with-reduce)\n\n### 3.2 Implement `filter` using `reduce`\n\nWhat should be changed in the solution of the previous exercise?\n\nWe can skip adding the current element if it does not satisfy the predicate, in which case the next accumulator will not change. However, if the current element does satisfy the predicate, we will set the next accumulator to be the current one, only enlarged by the current element\n\n[Solution](./ps1_sol.html#exercise-2-implementing-filter-with-reduce)\n\n### 3.3 Implement `some` and `every` using `map` and `reduce`\n\n`some(pred)` is a method that returns `true` if and only if *at least one* element in an array satisfies a given predicate.\n\n`every(pred)` is a method that returns true if and only if *all* the elements in an array satisfy a given predicate.\n\nFor example:\n\n```typescript\nlet even = (x => x % 2 == 0);\nlet arr1 = [1,2,3,4];\nlet arr2 = [1,3,5,7];\nlet arr3 = [2,4,6,8];\nlet arr1HasEvenNumbers = arr1.some(even);\nlet arr2HasEvenNumbers = arr2.some(even);\nlet allInArr1AreEven = arr1.every(even);\nlet allInArr3AreEven = arr3.every(even);\nconsole.log(`arr1HasEvenNumbers = ${arr1HasEvenNumbers}`); // ==> arr1HasEvenNumbers = true\nconsole.log(`arr2HasEvenNumbers = ${arr2HasEvenNumbers}`); // ==> arr2HasEvenNumbers = false\nconsole.log(`allInArr1AreEven = ${allInArr1AreEven}`); // ==> allInArr1AreEven = false\nconsole.log(`allInArr3AreEven = ${allInArr3AreEven}`); // ==> allInArr3AreEven = true\n```\n\nInstructions: \n\nA way to implement `some` is by mapping the array to `true/false` values of whether each element satisfies the predicate, and then doing an accumulated logical `or` between the elements using `reduce`, with the initial accumulator equal to `false`.\n\nSimilarly, we can implement `every` in the same way as above, except that we need to use a logical `and` and our initial accumulator should be `true`.\n\n[Solution](./ps1_sol.html#exercise-3-implementing-some-and-every-with-map-and-reduce)\n\n## Shortcut Semantics\n\nThe native `some` and `every` methods employ a concept known as 'shortcut semantics'. What this means, is that `some` stops and immediately returns `true` at the moment it finds an element that satisfies the predicate. `every` stops and immediately returns `false` at the moment it finds an element that does not satisfy the predicate.\n\n**Question**: does our implementation satisfy shortcut semantics?\n\nIt is difficult to distinguish between shortcut semantics and non-shortcut semantics because both shortcut and non-shortcut versions return the same values for all parameters.  \n\nCan we conclude that a shortcut and non-shortcut versions of `some` are equivalent according to the definition of function equivalence we provided in class?\n\nRemember though the difference between mathematical function equivalence and programming functions equivalence: 2 programming functions `f` and `g` are equivalent if they have the same domain, same range and for all values in the domain:\n* Either `f(x)` has a value and `g(x)` has the same value\n* Or `f(x)` does not terminate and `g(x)` does not terminate as well\n* Or `f(x)` throws an error and `g(x)` throws an error as well\n\nHow can we then distinguish between a shortcut semantics version of `some` and one that is not shortcut?\n\nThe solution is to choose parameters that will distinguish between the two computations using either non-termination (infinite loops) or errors.\n\nLet us define such an example on arrays of numbers.  We can trigger an error in JavaScript by using the `throw` primitive.\n\nTo test whether an error was thrown, we use the same syntax as in Java - with `try/catch`.\n\n```typescript\nconst throwOnZero = x => {\n    if (x > 0)\n        return true;\n    else\n        throw false;\n}\n\nlet a = [1, 0];\n\ntry {\n    a.some(throwOnZero);\n} catch (e) {\n    e;\n}\n```\n\nThe code above returns `true`.\n\n```typescript\nconst someExercise = (pred, arr) => arr.map(pred).reduce((acc, cur) => acc || cur, false);\n\ntry {\n    someExercise(throwOnZero, a);\n} catch (e) {\n    e;\n}\n```\n\nThe code above will return `false`.\n\nBy using deliberate error throwing, we are able to distinguish between shortcut and non-shortcut semantics on the definition of the `some` function.\n\nThe next question that arises is whether we can define a version of `some` using `reduce` that has shortcut semantics. We will revisit this question in Chapter 3 of the course, when we introduce generators.\n"
    },
    {
        "name": "ps2.md",
        "content": "# TypeScript: Type Checking\n\n## PPL 2023\n## Practical Session - Week #2\n\n### Why Types\n\nAdding types to a program has two key advantages:\n* It allows the compiler to detect errors that would otherwise only be detected at runtime. It is much better to detect errors as early as possible in the development cycle.\n* It serves as excellent documentation by reflecting the intention of the programmer.\n\nTypes also help programmers structure the code they write so that it follows the structure of the data it processes.\n\nIn this session, we review:\n* the syntax of type annotations in TypeScript\n* analyze an example of recursive type definition with the corresponding operations\n* analyze how the type of functions is derived\n\n### Types in TypeScript\n\nTypeScript adds optional type declarations to JavaScript.\nThe principles of this addition are:\n* Type declarations are optional. If they are present, they are checked, otherwise no check is performed. This means that regular JavaScript with no type annotations at all are valid TypeScript expressions.\n* The TypeScript compiler performs two tasks:\n    * It translates a TypeScript program into a JavaScript program\n    * It checks that the program satisfies all the type declarations specified in the program.\n* Type annotations can be implicit and inferred by the TypeScript compiler.\n\n\n```typescript\n// This TypeScript program\nfunction add(a: number, b: number): number {\n    return a + b;\n}\n\nadd(1, 3); // ==> 4\n\n// is translated by `tsc` into this JavaScript program:\nfunction add(a, b) {\n    return a + b;\n}\n\nadd(1, 3); // ==> 4\n```\n\n### Type Annotations\n\nType annotations are optional in TypeScript. They can occur in the following contexts:\n\n```typescript\n// After variable declarations\nlet varName: <typeAnnotation>; \n\n// As part of a function signature\nfunction fname(param : <typeAnnotation>, ...) : <typeAnnotation> { ... } \n\n// With fat arrow notation for functions\n(param: <typeAnnotation>, ...): <typeAnnotation> => ...\n```\n\nType annotations are written in a specific form - which we call the **type language**. \nThe type language is used to describe the expected type of variables, parameters or the values returned by functions.\n\nThe simplest type language expression refers to an **atomic type** - for example `number`, `boolean`, `string`. \nMore complex type language expressions are needed to describe types over compound values.\n\n### Array Type Expressions - Homogeneous Array\n\n\n```typescript\nlet numberArr : number[] = [1, 2, 3];\nlet num: number = numberArr[0];\nconsole.log(num); // ==> 1\n```\n\nOne may use the notation `Array<T>` instead of `T[]`.\n\n### Map Type Expressions\n\nTo describe map types, the following notation is used:\n\n```typescript\n{ <key>: <typeAnnotation>; ... }\n```\n\nFor example:\n\n```typescript\nlet s: { name: string, cs: boolean, age: number } = { name: \"avi\", cs: true, age: 22 };\ns; // => { name: 'avi', cs: true, age: 22 }\n```\n\n### Named Type Expressions\n\nType expressions can be given names. \n\nType expressions can be named using the type alias construct:\n\n```typescript\ntype <typeName> = {\n    <key>: <typeAnnotation>;\n    ...\n}\n```\n\nOr in general, to give a name to any type annotation:\n\n```typescript\ntype <typeName> = <typeAnnotation>;\n```\n\n```typescript\ntype Student = {\n    name: string;\n    cs: boolean;\n    age: number;\n}\n\nlet s: Student = { name: \"avi\", cs: true, age: 22 };\ns; // => { name: 'avi', cs: true, age: 22 }\n```\n\n### Recursive Types\n\nNaming types allows the definition of recursive types. Consider the case of defining a Linked List of numbers:\n\n\n```typescript\ntype NumberLink = {\n    num: number;\n    next?: NumberLink;\n}\n\nlet lst1: NumberLink = {\n    num: 1,\n    next: {\n        num: 2,\n        // The last element does NOT have a next field.\n        next: { num: 3 },\n    }\n};\n\nlst1; // => { num: 1, next: { num: 2, next: { num: 3 } } }\n```\n\n### Operations over Recursive Types\n\nThis type definition is *recursive* - we observe that the definition of the `NumberLink` uses the `NumberLink` type as a component of its own definition.  This type annotation defines a set of values.  Think of this set of values as the set of values which are `map` with a mandatory key `num` with a `number` value and a `next` key which can either not occur, or when it occurs must be of type `NumberLink`.  \n\nThis recursive type, thus, defines a set of *embedded* values - down to a terminal case, where the `next` key is not defined, and the embedding stops.\n\nGiven this type recursive definition, we can define procedures to traverse the linked list from start until a condition is met or until we reach the end of the list.  The following function illustrates the method:\n\n\n```typescript\nconst printNumberLinkedList: (list: NumberLink) => void = list => {\n    // We know list.num is a number\n    console.log(list.num);\n\n    // list.next can either be undefined or a NumberLink\n    if (list.next === undefined) {\n        console.log(\"end of list\");\n    } else {\n        // It is safe to pass a NumberLink value\n        // to the recursive call\n        printNumberLinkedList(list.next);\n    }\n};\n\nprintNumberLinkedList({ num: 1, next: { num: 2, next: { num: 3 } } });\n// ==>\n// 1\n// 2\n// 3\n// end of list\n```\n\nThe structure of the function follows the type definition - when the function receives a value of type `NumberLink`, it knows \nit is a map value, that must contain a `num` key which must be of type `number`.  It is thus safe to invoke `list.num` and to expect a `number` value.  \n\nThen when we need to access the `next` key - the type definition indicates we may find 2 different configurations:\n* Either `next` is not present - in which case, `list.next` will return the `undefined` value.\n* Or `next` is present and it must be a value of type NumberLink.\n\nThe code enumerates these options according to the type definition, and specifies what operations are possible according to the structure of the data that we process.\n\n### Generic Types\n\nConsider the case of defining an **homogeneous generic** Linked List.  This is an abstraction over the previous type definition - we make the type of the values in the linked list a type variable.  This is indicated by the `<T>` component in the type annotation.  \n\n\n```typescript\ntype Link<T> = {\n    x: T;\n    next?: Link<T>;\n}\n\n\nlet lst2: Link<string> = {\n    x: \"avi\",\n    next: { x: \"bob\", next: { x: \"charles\" } }\n};\n\nlst2; // ==> { x: 'avi', next: { x: 'bob', next: { x: 'charles' } } }\n```\n\nThe type variable, T, can be replaced with a compound type as well:\n\n```typescript\nlet lst3: Link<{ name: string }> = {\n    x: { name: \"xx\" },\n    next: { x: { name: \"yy\" }, next: { x: { name: \"last\" } } }\n};\n\nlst3; // ==> { x: { name: 'xx' }, next: { x: { name: 'yy' }, next: { x: [Object] } } }\n```\n\nConsider the case of defining an **heterogeneous** Linked List, we can use the special type called `any` - which denotes the set of all possible values that can be computed by the language:\n\n\n```typescript\nlet lst4: Link<any> = {\n    x: \"hi\",\n    next: { x: 1, next: { x: \"bye\" } }\n};\n\nlst4; // ==> { x: 'hi', next: { x: 1, next: { x: 'bye' } } }\n```\n\nHow can we write a function that operates over a generic data structure such as `Link<T>`?\nDoes the function need to know the type `T` to be useful at all?\n\nThere are three ways when it can be relevant to write an operation over a generic type:\n* Either the operation does not depend on knowledge of the type which is contained;\n* Or the operation itself is a generic function which can be applied to a variety of types.\n* Or we write an operation that is only applicable for a specific instance of the generic type.\n\nLet us see an example of each case: a function which counts how many elements are in a Linked List does not depend on the type of the elements in the list.  We can write it as follows:\n\n\n```typescript\nconst countLink: <T>(list: Link<T>) => number = (list) => {\n    return list.next === undefined ? 1 : 1 + countLink(list.next);\n};\n\ncountLink({ x: \"hi\", next: { x: \"hello\", next: { x: \"bye\" } } }); // => 3\n```\n\nNote how the type of the function must also be marked as a generic function - since it can be applied to parameters for any type `T`.  This is noted with the notation:\n\n```typescript\n<T>(list: Link<T>) => number;\n```\n\nFor the second case, consider the case of the primitive function `console.log()` - it can receive parameters of any type.\nIn this case, we can write a function that operates over the elements in the list even if they are of different types:\n\n\n```typescript\nconst printLink: <T>(list: Link<T>) => void = (list) => {\n    console.log(list.x);\n    list.next === undefined ? console.log(\"end of list\") : printLink(list.next);\n};\n\nprintLink({ x: \"hi\", next: { x: \"hello\", next: { x: \"bye\" } } });\n// ==>\n// hi\n// hello\n// bye\n// end of list\n\nprintLink({ x: 1, next: { x: 2, next: { x: 3 } } });\n// ==>\n// 1\n// 2\n// 3\n// end of list\n```\n\nNote that in the two invocations of the generic functions above, the compiler guesses the type of the parameter (`Link<string>` and `Link<number>`) from inspection of the literal.\n\nThe following invocation on a heterogeneous list, though, will not pass compilation:\n\n```typescript\nprintLink({ x: 1, next: { x: \"a\", next: { x: 3 } } });\n```\n\nThis is because the compiler will not infer on its own that the programmer intends to use an `any` type or a type union.\nTo make this work, the programmer must explicitly indicate that this is what is intended as follows:\n\n\n```typescript\nlet l: Link<any> = { x: 1, next: { x: \"a\", next: { x: 3 } } };\nprintLink(l);\n// ==>\n// 1\n// a\n// 3\n// end of list\n```\n\nThe third option to operate over a generic data type, is to create a function which operates specifically over a type instance of the type variable `T`.  For example, the following function operates only on `List<number>`:\n\n```typescript\nconst squareSumList: (list: Link<number>, acc: number) => number = (list, acc) => {\n    if (list.next === undefined) return acc + list.x * list.x;\n    else return squareSumList(list.next, acc + list.x * list.x);\n};\n\nsquareSumList({ x: 1, next: { x: 2, next: { x: 3 } } }, 0); // = 1*1 + 2*2 + 3*3\n// ==> 14\n```\n\n## Recursive Types: Tree Variations\n\n### Trees with Arbritrary Number of Children\n\nWe saw in class the definition of a `BinTree<T>` type specification. It demonstrated:\n\n* the need for naming types (with the `type` alias construct) to allow recursive type specification\n* the need to define optional properties in maps (with the `key?` notation) to allow the *end of the recursion* in the values.\n\n**Exercise:**\nDefine a Tree with an arbitrary number of children below each node.\n\n\n```typescript\ntype Tree<T> = {\n    root: T;\n    children: Tree<T>[];\n}\n\n// A tree of number nodes with just a root\nlet numbersTree: Tree<number> = {\n    root: 1,\n    children: []\n};\n\n// A tree of string nodes with just a root\nlet stringsTree: Tree<string> = {\n    root: \"tirgul 2\",\n    children: []\n};\n\n// A tree of numbers with one root and 2 children.\nlet t: Tree<number> = {\n    root: 1,\n    children: [\n        { root: 2, children: [] },\n        { root: 3, children: [] }\n    ]\n};\n\n// A heterogeneous tree with string and number nodes\nlet anyTree: Tree<any> = {\n    root: \"numbers and strings\",\n    children: [numbersTree, stringsTree]\n};\n\nanyTree;\n// ==>\n//    { root: 'numbers and strings',\n//      children: \n//       [ { root: 1, children: [] },\n//         { root: 'tirgul 2', children: [] } ] }\n```\n\n**QUESTIONS**: \nIn this case, we did not mark the field `children` as optional in the type definition.\nIt is `children: []` and not `children?: []` as it was in the case of `BinTree` or `Link` above.\n\nWhat is the difference?\n\nWhat are the arguments for and against defining `children` as optional?\n\n**ANSWERS**\n\nThe question is related to the definition of the **base case** vs. **inductive case** in the recursive definition of the type.\n* In the case of `BinTree` and `Link` above, we marked the base case with a key being `undefined`.\n* In the case of `Tree` with many children, we mark the base case with a key of type `Tree[]` being equal to `[]`.\n\nThe decision of what is the base case is completely in the hands of the programmer - so both options are legitimate.\n\nBut we must aim for a situation where the base case is **distinct** from the inductive case - so that they can be easily \ndistinguished when we write code that must decide whether we reached the end of the recursion.  We must make sure as much\nas possible that the type definition we provide allows us to encode:\n* *All the possible values* in the type\n* *Only the possible values* in the type.\n\nIf we defined `Tree` as:\n\n```typescript\ntype Tree<T> = {\n    root: T;\n    children?: Tree<T>[];\n}\n```\nwe could still define all the possible values as requested.\nBut the following two values would also be valid values of the type:\n\n```typescript\n{ root:1, children: [] }\n// and\n{ root: 1 }\n```\n\nThis means we would have two options to represent a leaf in a tree - which would mean it is an ambiguous representation. This would force us to test for the fact that a node is a leaf as follows:\n\n```typescript\nif (root.children.length === 0) || (root.children === undefined) {\n   // ...\n}\n```\nIn this case, we prefer to have a non-ambiguous way to mark the base case - and write only:\n\n```typescript\nif (root.children.length === 0) {\n   // ...\n}\n```\n\nThus, the definition of the type:\n\n```typescript\ntype Tree<T> = {\n    root: T;\n    children: Tree<T>[];\n}\n```\n**without** the `?` option is preferred.\n\n**Exercise:**\nCreate a function that follows a path within the tree and returns the node found at this place.\n\nFirst, how do we encode a path in this tree?\n\nA path must indicate a way to reach a specific node in the tree starting at the root and selecting one of the children at each step.\n\nFor example, let's look at this tree:\n\n\n```typescript\ntype Tree<T> = {\n    root: T;\n    children: Tree<T>[];\n}\n\nconst t: Tree<number> = {\n    root: 0,\n    children: [\n        { root: 2, children: [{ root: 4, children: [] }] },\n        { root: 1, children: [{ root: 3, children: [] }] }\n    ]\n};\n```\n\n![tree](./resources/ps2/tree.png)\n\nWe decide to encode paths as an array of numbers, indicating which child to select among the children of each node on the path:\n\n```\nthe path of the child with {root:4} will be [0,0]\nthe path of the child with {root:3} will be [1,0]\nthe path of the child with {root:2} will be [0]\nthe path of the child with {root:1} will be [1]\n``` \n\nWe know the type of the tree, so we can design a function that will not give errors at runtime.\n\n\n```typescript\nfunction getChild<T>(t: Tree<T>, path: number[]): Tree<T> {\n    if (path.length === 0)\n        // end of path\n        return t;\n    else if (t.children.length === 0)\n        // t is a leaf - cannot go down\n        return t;\n    else return getChild(t.children[path[0]], path.slice(1)); // recursive case\n}\nconsole.log(getChild(t, [0, 0])); // ==> { root: 2, children: [] }\nconsole.log(getChild(t, [1, 0])); // ==> { root: 3, children: [] }\nconsole.log(getChild(t, [1, 0, 0, 0])); // ==> { root: 3, children: [] } (Do not go \"after\" the leaves.)\n```\n\nIn the rest of the semester, we write functions in TypeScript in the style of functional programming, using the fat arrow syntax.\nThe same function will be defined as follows:\n\n```typescript\nconst getChild = <T>(t: Tree<T>, path: number[]): Tree<T> =>\n    // end of the path\n    (path.length === 0) ? t :\n    // t is a leaf - cannot go down\n    (t.children.length === 0) ? t : \n    // recursive case\n    getChild(t.children[path[0]], path.slice(1));\n\nconsole.log(getChild(t, [1, 0]));\n```\n\nThe differences are:\n* The function is defined as a const name and an anonymous function on the right hand side of the const\n* The body of the function is a single expression\n* We use the ternary if expression (as opposed to the if-statement) `test ? then : else`\n* There is no use for the `return` reserved word.\n\n## Function Types\n\n**Review**:\n\nFunctions in Functional Programming languages are values - that is, we can write expressions, which when they are evaluated at run time become functions (more precisely, *closures* - since these values are functions that may capture variable bindings).\n\nWe must have the ability to describe the type of these values and distinguish among different types of functions.\n\nAn untyped function in Javascript has the following form:\n\n```typescript\n// Named function (has global scope)\nfunction add(x, y) {\n    return x + y;\n}\n\n// Anonymous function\nconst myAdd = function (x, y) {\n    return x + y;\n};\n\n// Using the fat arrow notation:\nconst myFatAdd = (x, y) => x + y;\n\nmyFatAdd(3, 5); // ==> 8\n```\n\nWe can first specify the types of the parameters and the return type, in a way similar to the way it would be done in Java. This applies both to named functions and to anonymous functions.\n\n```typescript\n// Named function\nfunction addT(x: number, y: number): number {\n    return x + y;\n}\n\n// Anonymous function\nconst myAdd = function (x: number, y: number): number {\n    return x + y;\n};\n\n// Using the fat arrow notation:\nconst myFatAdd = (x: number, y: number): number => x + y;\n\nmyFatAdd(2, 4); // ==> 6\n```\n\nLet us now write the full type of the function out of the function value:\n\n```typescript\n\nconst myAdd: (x: number, y: number) => number = function (x: number, y: number): number {\n    return x + y;\n};\n\nconst myFatAdd: (x: number, y: number) => number = (x: number, y: number): number => x + y;\n\nmyFatAdd(2, 7); // ==> 9\n```\n\nThe type expression:\n\n```typescript\n(x: number, y: number) => number;\n```\nis a **function type**. The values that this type denotes are functions that map a pair of numbers to a number - in other words, functions whose domain is within  $$Number \\times Number$$ and whose range is within $$Number$$. (Remember that types denote a set of values.)\n\nThis function type together with the name of the parameters is also called the **function signature**.\n\nFunction types include parameter names and parameter types and a return type.\nParameter names are just to help with readability. We could have instead written:\n\n```typescript\nconst myAdd: (baseValue: number, increment: number) => number = function (x: number, y: number): number {\n    return x + y;\n};\n```\n\nAs long as the parameter types align, it\u2019s considered a valid type for the function, regardless of the names you give the parameters in the function type.\n\nThe second part of the function type is the return type. We make it clear which is the return type by using a fat arrow (**=>**) between the parameters and the return type. This is a required part of the function type, so if the function doesn\u2019t return a value (which means this is a function that just has a side-effect - no return value), we use the special type **void** instead of leaving it off.\n\n## Function Types Examples\n\n### 1. Square Function\n\n\n```typescript\nconst square = x => x * x;\nsquare(10); // ==> 100\n```\n\nThe **value** of `square` is a closure.\n\nThe **type** of `square` is: `(x: any) => number`.\n\nWe infer that the return type of the function is `number` because the value of the function is that which is returned when computing its body; the body is an expression of the form `x * x` and the primitive operator `*` returns a `number`.\n\nIn scheme we would also infer that the `x` variable must be of type `number` because it appears as an argument of the `*` operator which works on numbers.\n(We cannot do the same in JavaScript, why?)\n\n### 2. Generic Type Function\n\n```typescript\nconst id = x => x;\nconsole.log(`${id(0)}`); // ==> 0\nconsole.log(`${id(\"tirgul 2\")}`); // ==> tirgul 2\n```\n\nThe function id can be applied on any value - for example: string, boolean, number, but also arrays and maps.\n\nWe mark its argument as a type variable T1 and the type of the function is:\n\n```typescript\n<T1>(x: T1) => T1\n```\n\n**NOTE**: This is the most basic example of a **polymorphic function** - also called a **generic function**.\n\n**NOTE**: Defining this identity function as `<T1>(x: T1) => T1` is very different from defining it as<br> **`(x: any) => any`**. Can you explain why? Give examples of functions to illustrate.\n\n**NOTE**: To mark a function as generic in TypeScript, we must use the syntax:\n`function id<T>(x: T): T { return x; }`.\n\n###  3. Union Type Function\n\nConsider this function:\n\n```typescript\nlet unionFunc = x => {\n    if (x === 0) return 0;\n    else return false;\n};\n\nconsole.log(`${unionFunc(0)}`); // ==> 0\nconsole.log(`${unionFunc(5)}`); // ==> false\n```\n\n**NOTE**: the function can return two different types. \n\nHow can we describe its type? \n\nOne weak description is to use: `(x: number) => any`.\n\nA more informative description would be to use a *type union*:\n`<T1>(x: T1) => number | boolean`.\n\nNote that we could infer that `x` is of type `number` because we compare it to `0`.\nBut the operator `===` is a universal operator in JavaScript and does not require its parameters to be of the same type. In other words, the primitive `===` has type: `(x: any, y: any) => boolean`.\n\n**NOTE**: Do we want to define functions which return union types of this sort?\n\n**Answer**: This is **not** a good idea.  Such functions are surely not defined well if their return value must be described by a *complicated* type of this sort - it is almost always the sign of a bug.\n\nSuch return values are very complicated to consume - if we want to call this function, we must always test the return value as:\n\n```typescript\nlet x = unionFunc(2);\n\nif (typeof x === \"number\")\n    return x + 2;\nelse\n    return 0;\n```\nand we will almost never be able to invoke `g(unionFunc(2))` for usual functions.\n\n### 4. Map Function Type\n\nWe can apply map (of the ramda package) on varied arguments:\n\n```typescript\nimport { map } from \"ramda\";\n\nlet numbersArray = map(x => x + 1, [1, 2, 3]);\nlet stringsArray = map(x => x + \"d\", [\"a\", \"b\", \"c\"]);\nconsole.log(numbersArray); // ==> [ 2, 3, 4 ]\nconsole.log(stringsArray); // ==> [ 'ad', 'bd', 'cd' ]\n```\n\n`map` receives two arguments: a function and an array.\n\nLet us name them `func` and `array`.\n\n`array` can contain items of any type - let us mark it as T1 under the assumption that the array is **homogeneous**.\n\n`func` gets one parameter - which must be of the type of the elements in `array`.\n\nFor each item in `array` it returns a value of a given type - let us call this return type `T2`.\n\nThe type of the parameter `func` is therefore: `(x:T1)=>T2`.\n\nThe value returned by `map` is an array of the values returned by `func` - that is, its type is `T2[]`.\n\nPutting all the elements together: the type of the `map` function is: \n\n```typescript\n<T1, T2>(func: (x: T1) => T2, array: T1[]) => T2[]\n```\n\n### 5. Filter Function Type\n\nWe can apply `filter` (of the ramda package) on varied arguments:\n\n```typescript\nimport { filter } from \"ramda\";\n\nlet numbersArray = filter(x => x % 2 === 0, [1, 2, 3]);\nlet stringsArray = filter(x => x[0] === \"d\", [\"david\", \"dani\", \"moshe\"]);\nconsole.log(numbersArray); // ==> [ 2 ]\nconsole.log(stringsArray); // ==> [ 'david', 'dani' ]\n```\n\nSo what should be the type of the `filter` function?\n\n`filter` receives two parameters: a function `pred` and an `array`.\n\n`array` can contain items of any type - let us call it `T1` under the assumption that the array is **homogeneous**.\n\n`pred` is a function, that gets one parameter of type `T1` and returns a `boolean` value.\n\n`filter` returns a sub-array of the original array, so that the type it returns is `T1[]`.\n\nPutting all elements together, the type of the `filter` function is:\n\n```typescript\n<T1>(pred: (x: T1) => boolean, array: T1[]) => T1[]\n```\n\n### 6. Reduce Function Type\n\nWe can apply `reduce` (of the ramda package) on varied arguments:\n\n```typescript\nimport { reduce } from 'ramda'\n\nlet num = reduce((acc, curr) => acc + curr, 0, [1, 2, 3]);\nlet count = reduce((acc, curr) => acc + curr.length, 0, [\"a\", \"bc\", \"def\"]);\nconsole.log(num); // ==> 6\nconsole.log(count); // ==> 6\n```\n\nSo what should be the type of the `reduce` function?\n\n`reduce` receives 3 arguments: \n* The reducer function `reducer`\n* The initial value `init`\n* The `array`\n\nThe elements of `array` can be of any type - let us call it `T1` under the assumption that the array is **homogeneous**.\n\n`reducer` gets two parameters (`acc` and `curr`) and outputs a value that will be the `acc` at the next iteration.\n`curr` is one of the items of `array` at each iteration.  \nWe infer that:\n* `curr` must be of type `T1` (same type as the elements in `array`)\n* `acc` and `init` must be of the same type `T2`\n* `reducer` is of type: `(acc: T2, curr: T1)=>T2`.\n\n`reduce` eventually returns the last value of `acc` returned by `reducer` - so the type of the return value should be `T2`.\n\nPutting all things together, the type of `reduce` is:\n\n```typescript\n<T1, T2>(reducer: (acc: T2, curr: T1) => T2, init: T2, array: T1[]) => T2\n```\n\n## 7. Compose Function Type\n\nCompose receives two function arguments `f` and `g` and returns a new function as a value:\n\n```typescript\nimport { compose } from 'ramda'\nlet hn = compose(y => y * y, x => x + 1);\nhn(3); // ==> (3 + 1) * (3 + 1) = 16\n```\n\n```typescript\n// Reverse a string: \n// - Make an array of chars out of the string (split(\"\"))\n// - Reverse the array\n// - Join the chars back into a string array.join(\"\")\nconst reverse: (s: string) => string = s => s.split(\"\").reverse().join(\"\");\nreverse(\"abcd\"); // ==> 'dcba'\n```\n\n```typescript\n// Return a new string with all upper case chars\nconst upper: (s: string) => string = s => s.toUpperCase();\nupper(\"abcd\"); // ==> 'ABCD'\n```\n\n```typescript\nlet upperReverse: (s: string) => string = compose(reverse, upper);\nupperReverse(\"abcd\"); // ==> 'DCBA'\n```\n\nWhat is the type of the function `compose`?\n\nThe first parameter `f` receives a value of any type, let us call it `T1` and returns a value of any type `T2`.\n\nThe second parameter `g` receives a value of any type, `T3` and returns a value of any type `T4`.\n\nThe returned value is a function which computes `f(g(x))` for any parameter `x`.\n\nWe infer that the returned function must receive parameters of the same type as `g` - that is `T3`.\n\nIn addition, we infer that the value returned by `g(x)` must be of the type that `f` expects - that is, `T4` must be the same as `T1`.\n\nFinally, the value returned by `f(g(x))` is of the same type as that returned by `f` - that is, `T2`.\n\nPutting all things together - the type of `compose` is:\n\n```typescript\n<T1, T2, T3>(f: (y: T1) => T2, g: (x: T3) => T1) => (x: T3) => T2;\n```\n\nIt helps to renumber the type variables according to the order in which they are computed:\n\n```typescript\n<T1, T2, T3>(f: (y: T2) => T3, g: (x: T1) => T2) => (x: T1) => T3;\n```\n\nwhich can be read as: a value `x` of type `T1` is mapped to a value of type `T2` and then to a value of type `T3`.\n"
    }
]